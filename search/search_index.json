{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Task 1: Theoretical Foundation 1.1 Equations of Motion for Projectile Motion The governing equations of motion for a projectile are derived from the basic principles of physics: Newton's Laws of Motion and the equations of constant acceleration . We will assume there is no air resistance in this idealized scenario. Horizontal Motion: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: - \\(x(t)\\) is the horizontal position at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(t\\) is the time. Vertical Motion: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: - \\(y(t)\\) is the vertical position at time \\(t\\) , - \\(g\\) is the acceleration due to gravity ( \\(9.81 \\, \\text{m/s}^2\\) ). These two equations describe the horizontal and vertical positions of the projectile at any given time \\(t\\) . 1.2 Time of Flight The time of flight is the total time the projectile remains in the air before it hits the ground. To find this, we set the vertical position equal to zero at the time of impact: \\[ y(t_f) = 0 \\] Substitute the vertical motion equation: \\[ v_0 \\sin(\\theta) \\cdot t_f - \\frac{1}{2} g t_f^2 = 0 \\] Factoring out \\(t_f\\) : \\[ t_f \\left( v_0 \\sin(\\theta) - \\frac{1}{2} g t_f \\right) = 0 \\] Solving for \\(t_f\\) (ignoring the trivial solution \\(t_f = 0\\) ): \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Thus, the time of flight depends on the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) . 1.3 Range of the Projectile The range \\(R\\) is the horizontal distance the projectile travels before hitting the ground. It is given by the horizontal motion equation at the time of flight \\(t_f\\) : \\[ R = x(t_f) = v_0 \\cdot \\cos(\\theta) \\cdot t_f \\] Substitute the time of flight \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) into the equation for range: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the formula for the range of a projectile. 1.4 Family of Solutions Based on Initial Conditions The range \\(R\\) depends on two variables: the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) . Effect of Initial Velocity \\(v_0\\) : A higher initial velocity increases the range. Effect of Angle of Projection \\(\\theta\\) : The range \\(R\\) is a function of \\(\\sin(2\\theta)\\) . Therefore, the range will be maximized when \\(\\theta = 45^\\circ\\) , since \\(\\sin(90^\\circ) = 1\\) . By varying the initial velocity or launch angle, we obtain a family of solutions describing the projectile's behavior. Task 1.2 Analysis of the Range Introduction In projectile motion, the horizontal range \\( R \\) is the distance a projectile travels before hitting the ground. It depends on the angle of projection \\( \\theta \\) , the initial velocity \\( v_0 \\) , and the gravitational acceleration \\( g \\) . This task investigates how the range varies with the angle of projection and how other parameters influence this relationship. Governing Equations The horizontal range \\( R \\) of a projectile launched at an angle \\( \\theta \\) with initial velocity \\( v_0 \\) is given by: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation assumes: - No air resistance. - A flat, horizontal surface. - Constant gravitational acceleration \\( g \\) . Python Script for Simulation Below is a Python script to simulate the range as a function of the angle of projection and visualize the results. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s^2) v0 = 50 # Initial velocity (m/s) # Function to calculate range def calculate_range(theta, v0, g): theta_rad = np.radians(theta) # Convert angle to radians return (v0**2 * np.sin(2 * theta_rad)) / g # Generate angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) ranges = calculate_range(angles, v0, g) # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f\"v0 = {v0} m/s, g = {g} m/s\u00b2\") plt.title(\"Range vs Angle of Projection\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.legend() plt.show() Graphical Representation The graph above shows the range \\( R \\) as a function of the angle of projection \\( \\theta \\) . Key observations: 1. The range is maximum at \\( \\theta = 45^\\circ \\) . 2. The range is symmetric around \\( 45^\\circ \\) . 3. For angles \\( \\theta < 45^\\circ \\) and \\( \\theta > 45^\\circ \\) , the range decreases. Influence of Parameters Initial Velocity \\( v_0 \\) : Increasing \\( v_0 \\) increases the range quadratically, as \\( R \\propto v_0^2 \\) . Decreasing \\( v_0 \\) reduces the range. Gravitational Acceleration \\( g \\) : Increasing \\( g \\) decreases the range, as \\( R \\propto \\frac{1}{g} \\) . Decreasing \\( g \\) increases the range. Task 1.3 Practical Applications Introduction The idealized model of projectile motion assumes: - No air resistance. - A flat, horizontal surface. - Constant gravitational acceleration \\( g \\) . However, real-world scenarios often involve additional factors such as air resistance, uneven terrain, and variable gravitational fields. This task explores how the model can be adapted to describe these situations. 1. Air Resistance (Drag Force) In real-world scenarios, air resistance significantly affects the motion of a projectile. The drag force \\( F_d \\) acts opposite to the direction of motion and is given by: $$ F_d = \\frac{1}{2} \\rho v^2 C_d A $$ where: - \\( \\rho \\) is the air density, - \\( v \\) is the velocity of the projectile, - \\( C_d \\) is the drag coefficient, - \\( A \\) is the cross-sectional area of the projectile. Adapting the Model To incorporate air resistance, the equations of motion must include the drag force. The modified equations are: $$ \\frac{dv_x}{dt} = -\\frac{F_d}{m} \\cos(\\theta) $$ $$ \\frac{dv_y}{dt} = -g - \\frac{F_d}{m} \\sin(\\theta) $$ These equations require numerical methods (e.g., Euler's method or Runge-Kutta) for solving. Python Script for Simulation with Air Resistance import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s\u00b2) v0 = 50 # Initial velocity (m/s) theta = 45 # Angle of projection (degrees) m = 0.1 # Mass of projectile (kg) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) dt = 0.01 # Time step (s) # Initial conditions vx = v0 * np.cos(np.radians(theta)) vy = v0 * np.sin(np.radians(theta)) x, y = 0, 0 # Lists to store trajectory x_vals, y_vals = [], [] # Simulation loop while y >= 0: v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * rho * v**2 * Cd * A ax = -Fd * vx / (m * v) ay = -g - Fd * vy / (m * v) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_vals.append(x) y_vals.append(y) # Plotting plt.figure(figsize=(10, 6)) plt.plot(x_vals, y_vals, label=\"With Air Resistance\") plt.title(\"Projectile Motion with Air Resistance\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() 2. Uneven Terrain In real-world scenarios, the ground may not be flat. For example, a projectile launched from a hill or into a valley will have a different range compared to flat terrain. Adapting the Model To account for uneven terrain, the elevation \\( y \\) of the ground at a given horizontal distance \\( x \\) must be modeled. The projectile's trajectory is then compared to the ground elevation to determine when it lands. Python Script for Uneven Terrain # Define ground elevation as a function of x def ground_elevation(x): return 0.1 * x - 0.001 * x**2 # Example: Parabolic terrain # Simulation loop for uneven terrain x, y = 0, 0 x_vals, y_vals = [], [] while y >= ground_elevation(x): v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * rho * v**2 * Cd * A ax = -Fd * vx / (m * v) ay = -g - Fd * vy / (m * v) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_vals.append(x) y_vals.append(y) # Plotting plt.figure(figsize=(10, 6)) plt.plot(x_vals, y_vals, label=\"Projectile Trajectory\") plt.plot(x_vals, [ground_elevation(x) for x in x_vals], label=\"Ground Elevation\", linestyle=\"--\") plt.title(\"Projectile Motion on Uneven Terrain\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show() 3. Variable Gravitational Fields For projectiles launched over very large distances (e.g., intercontinental ballistic missiles), the gravitational acceleration \\( g \\) is not constant. It decreases with altitude according to: $$ g(h) = \\frac{GM}{(R + h)^2} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the Earth, - \\( R \\) is the radius of the Earth, - \\( h \\) is the altitude. Adapting the Model The gravitational acceleration \\( g \\) must be updated at each time step based on the projectile's altitude \\( h \\) . Conclusion The idealized projectile motion model can be adapted to real-world scenarios by incorporating: 1. Air resistance (drag force). 2. Uneven terrain. 3. Variable gravitational fields. These adaptations make the model more realistic and applicable to practical situations such as sports, engineering, and space exploration. Task 1.4: Implementation: Python Code for Simulation and Visualization Below is the Python script to simulate projectile motion and visualize the range as a function of the angle of projection for different initial conditions. import numpy as np import matplotlib.pyplot as plt # Function to calculate the range of a projectile def calculate_range(theta, v0, g): \"\"\" Calculate the horizontal range of a projectile. Parameters: theta (float): Angle of projection in degrees. v0 (float): Initial velocity in m/s. g (float): Gravitational acceleration in m/s\u00b2. Returns: float: Horizontal range in meters. \"\"\" theta_rad = np.radians(theta) # Convert angle to radians return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters v0_values = [30, 50, 70] # Different initial velocities (m/s) g_values = [9.81, 1.62] # Gravitational acceleration (Earth and Moon) (m/s\u00b2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Plotting plt.figure(figsize=(12, 8)) # Loop over initial velocities for v0 in v0_values: # Loop over gravitational accelerations for g in g_values: ranges = calculate_range(angles, v0, g) plt.plot(angles, ranges, label=f\"v0 = {v0} m/s, g = {g} m/s\u00b2\") # Customize plot plt.title(\"Range vs Angle of Projection for Different Initial Conditions\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.legend() plt.show() Explanation of the Code Function calculate_range : This function calculates the horizontal range \\(R\\) of a projectile using the formula: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ It takes the angle of projection \\(\\theta\\) (in degrees), initial velocity \\(v_0\\) , and gravitational acceleration \\(g\\) as inputs and returns the range \\(R\\) . Parameters: v0_values : A list of initial velocities (e.g., 30 m/s, 50 m/s, 70 m/s). g_values : A list of gravitational accelerations (e.g., 9.81 m/s\u00b2 for Earth, 1.62 m/s\u00b2 for the Moon). angles : An array of angles from 0 to 90 degrees. Plotting: The code loops over each combination of initial velocity and gravitational acceleration. For each combination, it calculates the range for all angles and plots the results. The plot is customized with a title, axis labels, grid, and legend. How to Run the Code Copy the Python script into a new file in Visual Studio Code (e.g., projectile_motion.py ). Save the file and run it. A graph will appear showing the range as a function of the angle of projection for different initial conditions. Expected Output The graph will display: - Multiple curves, each representing a combination of initial velocity and gravitational acceleration. - The maximum range occurs at \\(45^\\circ\\) for all cases. - Higher initial velocities result in greater ranges. - Lower gravitational accelerations (e.g., on the Moon) result in greater ranges. Next Steps Extend the simulation to include air resistance or drag. Explore the effect of uneven terrain on the range. ```","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-1-theoretical-foundation","text":"","title":"Task 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion-for-projectile-motion","text":"The governing equations of motion for a projectile are derived from the basic principles of physics: Newton's Laws of Motion and the equations of constant acceleration . We will assume there is no air resistance in this idealized scenario.","title":"1.1 Equations of Motion for Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: - \\(x(t)\\) is the horizontal position at time \\(t\\) , - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(t\\) is the time.","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: - \\(y(t)\\) is the vertical position at time \\(t\\) , - \\(g\\) is the acceleration due to gravity ( \\(9.81 \\, \\text{m/s}^2\\) ). These two equations describe the horizontal and vertical positions of the projectile at any given time \\(t\\) .","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time of flight is the total time the projectile remains in the air before it hits the ground. To find this, we set the vertical position equal to zero at the time of impact: \\[ y(t_f) = 0 \\] Substitute the vertical motion equation: \\[ v_0 \\sin(\\theta) \\cdot t_f - \\frac{1}{2} g t_f^2 = 0 \\] Factoring out \\(t_f\\) : \\[ t_f \\left( v_0 \\sin(\\theta) - \\frac{1}{2} g t_f \\right) = 0 \\] Solving for \\(t_f\\) (ignoring the trivial solution \\(t_f = 0\\) ): \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Thus, the time of flight depends on the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) .","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-of-the-projectile","text":"The range \\(R\\) is the horizontal distance the projectile travels before hitting the ground. It is given by the horizontal motion equation at the time of flight \\(t_f\\) : \\[ R = x(t_f) = v_0 \\cdot \\cos(\\theta) \\cdot t_f \\] Substitute the time of flight \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) into the equation for range: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the formula for the range of a projectile.","title":"1.3 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions-based-on-initial-conditions","text":"The range \\(R\\) depends on two variables: the initial velocity \\(v_0\\) and the angle of projection \\(\\theta\\) . Effect of Initial Velocity \\(v_0\\) : A higher initial velocity increases the range. Effect of Angle of Projection \\(\\theta\\) : The range \\(R\\) is a function of \\(\\sin(2\\theta)\\) . Therefore, the range will be maximized when \\(\\theta = 45^\\circ\\) , since \\(\\sin(90^\\circ) = 1\\) . By varying the initial velocity or launch angle, we obtain a family of solutions describing the projectile's behavior.","title":"1.4 Family of Solutions Based on Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-12-analysis-of-the-range","text":"","title":"Task 1.2 Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction","text":"In projectile motion, the horizontal range \\( R \\) is the distance a projectile travels before hitting the ground. It depends on the angle of projection \\( \\theta \\) , the initial velocity \\( v_0 \\) , and the gravitational acceleration \\( g \\) . This task investigates how the range varies with the angle of projection and how other parameters influence this relationship.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"The horizontal range \\( R \\) of a projectile launched at an angle \\( \\theta \\) with initial velocity \\( v_0 \\) is given by: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation assumes: - No air resistance. - A flat, horizontal surface. - Constant gravitational acceleration \\( g \\) .","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-script-for-simulation","text":"Below is a Python script to simulate the range as a function of the angle of projection and visualize the results. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s^2) v0 = 50 # Initial velocity (m/s) # Function to calculate range def calculate_range(theta, v0, g): theta_rad = np.radians(theta) # Convert angle to radians return (v0**2 * np.sin(2 * theta_rad)) / g # Generate angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) ranges = calculate_range(angles, v0, g) # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, label=f\"v0 = {v0} m/s, g = {g} m/s\u00b2\") plt.title(\"Range vs Angle of Projection\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.legend() plt.show()","title":"Python Script for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-representation","text":"The graph above shows the range \\( R \\) as a function of the angle of projection \\( \\theta \\) . Key observations: 1. The range is maximum at \\( \\theta = 45^\\circ \\) . 2. The range is symmetric around \\( 45^\\circ \\) . 3. For angles \\( \\theta < 45^\\circ \\) and \\( \\theta > 45^\\circ \\) , the range decreases.","title":"Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial Velocity \\( v_0 \\) : Increasing \\( v_0 \\) increases the range quadratically, as \\( R \\propto v_0^2 \\) . Decreasing \\( v_0 \\) reduces the range. Gravitational Acceleration \\( g \\) : Increasing \\( g \\) decreases the range, as \\( R \\propto \\frac{1}{g} \\) . Decreasing \\( g \\) increases the range.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-13-practical-applications","text":"","title":"Task 1.3 Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction_1","text":"The idealized model of projectile motion assumes: - No air resistance. - A flat, horizontal surface. - Constant gravitational acceleration \\( g \\) . However, real-world scenarios often involve additional factors such as air resistance, uneven terrain, and variable gravitational fields. This task explores how the model can be adapted to describe these situations.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-air-resistance-drag-force","text":"In real-world scenarios, air resistance significantly affects the motion of a projectile. The drag force \\( F_d \\) acts opposite to the direction of motion and is given by: $$ F_d = \\frac{1}{2} \\rho v^2 C_d A $$ where: - \\( \\rho \\) is the air density, - \\( v \\) is the velocity of the projectile, - \\( C_d \\) is the drag coefficient, - \\( A \\) is the cross-sectional area of the projectile.","title":"1. Air Resistance (Drag Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adapting-the-model","text":"To incorporate air resistance, the equations of motion must include the drag force. The modified equations are: $$ \\frac{dv_x}{dt} = -\\frac{F_d}{m} \\cos(\\theta) $$ $$ \\frac{dv_y}{dt} = -g - \\frac{F_d}{m} \\sin(\\theta) $$ These equations require numerical methods (e.g., Euler's method or Runge-Kutta) for solving.","title":"Adapting the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-script-for-simulation-with-air-resistance","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s\u00b2) v0 = 50 # Initial velocity (m/s) theta = 45 # Angle of projection (degrees) m = 0.1 # Mass of projectile (kg) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) dt = 0.01 # Time step (s) # Initial conditions vx = v0 * np.cos(np.radians(theta)) vy = v0 * np.sin(np.radians(theta)) x, y = 0, 0 # Lists to store trajectory x_vals, y_vals = [], [] # Simulation loop while y >= 0: v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * rho * v**2 * Cd * A ax = -Fd * vx / (m * v) ay = -g - Fd * vy / (m * v) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_vals.append(x) y_vals.append(y) # Plotting plt.figure(figsize=(10, 6)) plt.plot(x_vals, y_vals, label=\"With Air Resistance\") plt.title(\"Projectile Motion with Air Resistance\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show()","title":"Python Script for Simulation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-uneven-terrain","text":"In real-world scenarios, the ground may not be flat. For example, a projectile launched from a hill or into a valley will have a different range compared to flat terrain.","title":"2. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adapting-the-model_1","text":"To account for uneven terrain, the elevation \\( y \\) of the ground at a given horizontal distance \\( x \\) must be modeled. The projectile's trajectory is then compared to the ground elevation to determine when it lands.","title":"Adapting the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-script-for-uneven-terrain","text":"# Define ground elevation as a function of x def ground_elevation(x): return 0.1 * x - 0.001 * x**2 # Example: Parabolic terrain # Simulation loop for uneven terrain x, y = 0, 0 x_vals, y_vals = [], [] while y >= ground_elevation(x): v = np.sqrt(vx**2 + vy**2) Fd = 0.5 * rho * v**2 * Cd * A ax = -Fd * vx / (m * v) ay = -g - Fd * vy / (m * v) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_vals.append(x) y_vals.append(y) # Plotting plt.figure(figsize=(10, 6)) plt.plot(x_vals, y_vals, label=\"Projectile Trajectory\") plt.plot(x_vals, [ground_elevation(x) for x in x_vals], label=\"Ground Elevation\", linestyle=\"--\") plt.title(\"Projectile Motion on Uneven Terrain\") plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.grid(True) plt.legend() plt.show()","title":"Python Script for Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-variable-gravitational-fields","text":"For projectiles launched over very large distances (e.g., intercontinental ballistic missiles), the gravitational acceleration \\( g \\) is not constant. It decreases with altitude according to: $$ g(h) = \\frac{GM}{(R + h)^2} $$ where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the Earth, - \\( R \\) is the radius of the Earth, - \\( h \\) is the altitude.","title":"3. Variable Gravitational Fields"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#adapting-the-model_2","text":"The gravitational acceleration \\( g \\) must be updated at each time step based on the projectile's altitude \\( h \\) .","title":"Adapting the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The idealized projectile motion model can be adapted to real-world scenarios by incorporating: 1. Air resistance (drag force). 2. Uneven terrain. 3. Variable gravitational fields. These adaptations make the model more realistic and applicable to practical situations such as sports, engineering, and space exploration.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task-14-implementation","text":"","title":"Task 1.4: Implementation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-for-simulation-and-visualization","text":"Below is the Python script to simulate projectile motion and visualize the range as a function of the angle of projection for different initial conditions. import numpy as np import matplotlib.pyplot as plt # Function to calculate the range of a projectile def calculate_range(theta, v0, g): \"\"\" Calculate the horizontal range of a projectile. Parameters: theta (float): Angle of projection in degrees. v0 (float): Initial velocity in m/s. g (float): Gravitational acceleration in m/s\u00b2. Returns: float: Horizontal range in meters. \"\"\" theta_rad = np.radians(theta) # Convert angle to radians return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters v0_values = [30, 50, 70] # Different initial velocities (m/s) g_values = [9.81, 1.62] # Gravitational acceleration (Earth and Moon) (m/s\u00b2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Plotting plt.figure(figsize=(12, 8)) # Loop over initial velocities for v0 in v0_values: # Loop over gravitational accelerations for g in g_values: ranges = calculate_range(angles, v0, g) plt.plot(angles, ranges, label=f\"v0 = {v0} m/s, g = {g} m/s\u00b2\") # Customize plot plt.title(\"Range vs Angle of Projection for Different Initial Conditions\") plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.grid(True) plt.legend() plt.show()","title":"Python Code for Simulation and Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-code","text":"Function calculate_range : This function calculates the horizontal range \\(R\\) of a projectile using the formula: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ It takes the angle of projection \\(\\theta\\) (in degrees), initial velocity \\(v_0\\) , and gravitational acceleration \\(g\\) as inputs and returns the range \\(R\\) . Parameters: v0_values : A list of initial velocities (e.g., 30 m/s, 50 m/s, 70 m/s). g_values : A list of gravitational accelerations (e.g., 9.81 m/s\u00b2 for Earth, 1.62 m/s\u00b2 for the Moon). angles : An array of angles from 0 to 90 degrees. Plotting: The code loops over each combination of initial velocity and gravitational acceleration. For each combination, it calculates the range for all angles and plots the results. The plot is customized with a title, axis labels, grid, and legend.","title":"Explanation of the Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#how-to-run-the-code","text":"Copy the Python script into a new file in Visual Studio Code (e.g., projectile_motion.py ). Save the file and run it. A graph will appear showing the range as a function of the angle of projection for different initial conditions.","title":"How to Run the Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#expected-output","text":"The graph will display: - Multiple curves, each representing a combination of initial velocity and gravitational acceleration. - The maximum range occurs at \\(45^\\circ\\) for all cases. - Higher initial velocities result in greater ranges. - Lower gravitational accelerations (e.g., on the Moon) result in greater ranges.","title":"Expected Output"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#next-steps","text":"Extend the simulation to include air resistance or drag. Explore the effect of uneven terrain on the range. ```","title":"Next Steps"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum: Theoretical and Computational Analysis Task 1.1: Theoretical Foundation The equation of motion for a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - $ \\theta $ is the angular displacement. - $ b $ is the damping coefficient. - $ g $ is the acceleration due to gravity. - $ L $ is the length of the pendulum. - $ A $ is the amplitude of the external forcing. - $ \\omega $ is the frequency of the external driving force. Small Angle Approximation For small angles, we can approximate: \\[ \\sin(\\theta) \\approx \\theta \\] This simplifies the equation of motion to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear second-order ordinary differential equation that describes the motion of the forced damped pendulum under the small-angle approximation. Solution to the Homogeneous Equation The homogeneous part of the equation is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] The general solution to this equation depends on the damping coefficient $ b $. The solution is of the form: \\[ \\theta(t) = e^{-\\gamma t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right) \\] Where: - $ \\gamma = \\frac{b}{2m} $ is the damping coefficient. - $ \\omega_d = \\sqrt{\\frac{g}{L} - \\gamma^2} $ is the damped frequency. Forced Solution The particular solution to the non-homogeneous equation is of the form: \\[ \\theta(t) = \\frac{A}{\\sqrt{\\left( \\frac{g}{L} - \\omega^2 \\right)^2 + (b \\omega)^2}} \\cos(\\omega t - \\delta) \\] Where $ \\delta $ is the phase shift given by: \\[ \\tan(\\delta) = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\] This solution describes the motion of the pendulum under periodic forcing. The amplitude of the oscillation depends on the frequency $ \\omega $ and the damping coefficient $ b $. Resonance and Energy Resonance occurs when the frequency of the external driving force matches the natural frequency of the pendulum. The natural frequency is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude of the oscillations increases significantly. The energy absorbed by the system from the external force is maximized when the driving frequency is equal to the natural frequency. This leads to large oscillations, potentially causing instability in the system. Task 1.1.2: Numerical Solution and Simulations To explore the dynamics of the forced damped pendulum numerically, we will employ numerical methods such as the Runge-Kutta method. We will also visualize the motion for different values of the damping coefficient, driving amplitude, and frequency. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of ODEs for the forced damped pendulum def pendulum(t, y, b, g, L, A, omega): theta, omega_ = y dydt = [omega_, -b*omega_ - (g/L)*np.sin(theta) + A*np.cos(omega*t)] return dydt # Parameters b = 0.1 # Damping coefficient g = 9.81 # Gravitational acceleration L = 1.0 # Length of the pendulum A = 1.0 # Amplitude of the external forcing omega = 1.5 # Frequency of the external force # Initial conditions [theta, omega] y0 = [0.1, 0.0] # Time array t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Solve the ODE solution = solve_ivp(pendulum, t_span, y0, args=(b, g, L, A, omega), t_eval=t_eval) # Plotting the results plt.figure(figsize=(10, 6)) plt.plot(solution.t, solution.y[0], label=r'$\\theta(t)$') plt.title('Forced Damped Pendulum Motion') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.grid(True) plt.legend() plt.show() Graphical Representations By modifying the values of the damping coefficient $ b $, driving amplitude $ A $, and frequency $ \\omega $, you can observe different behaviors of the pendulum, such as underdamped, critically damped, and overdamped motion, as well as resonance effects when $ \\omega \\approx \\sqrt{\\frac{g}{L}} $. Task 1.1.3: Phase Portraits and Poincar\u00e9 Sections Phase portraits help us visualize the state of the system in the phase plane (angular displacement vs. angular velocity). This is useful for understanding the system's long-term behavior, including periodic and chaotic solutions. # Phase portrait for different initial conditions def phase_portrait(b, g, L, A, omega, theta0, omega0): y0 = [theta0, omega0] solution = solve_ivp(pendulum, t_span, y0, args=(b, g, L, A, omega), t_eval=t_eval) return solution.t, solution.y[0], solution.y[1] # Example phase portrait t, theta, omega = phase_portrait(b, g, L, A, omega, 0.1, 0.0) # Plot phase portrait plt.figure(figsize=(8, 6)) plt.plot(theta, omega) plt.title('Phase Portrait of the Forced Damped Pendulum') plt.xlabel('Angular Displacement (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show() Task 1.1.4: Discussion and Extensions Limitations of the Model Small-Angle Approximation: The approximation $ \\sin(\\theta) \\approx \\theta $ holds only for small angles. For large displacements, the full nonlinear equation should be used. Linear Damping and Forcing: The model assumes linear damping and periodic forcing. Real-world systems may involve nonlinear damping or non-periodic forcing, which can lead to more complex behaviors. Potential Extensions Nonlinear Damping: The damping term can be made nonlinear (e.g., $ b(\\theta) = \\alpha \\theta^2 $) to model systems where the damping increases with amplitude. Non-Periodic Driving Force: Introducing a random or aperiodic driving force could model systems that are more unpredictable, such as climate models or biological rhythms. Task 2: Analysis of Dynamics The equation of motion for the forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - $ \\theta $ is the angular displacement of the pendulum. - $ b $ is the damping coefficient, which characterizes the friction or resistive forces. - $ g $ is the acceleration due to gravity. - $ L $ is the length of the pendulum. - $ A $ is the amplitude of the external driving force. - $ \\omega $ is the frequency of the external driving force. For small angles, we approximate $ \\sin(\\theta) \\approx \\theta $, simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] Influence of the Damping Coefficient ($ b $) The damping coefficient $ b $ governs the rate at which the oscillations decay. The behavior of the system can be categorized as: 1. Underdamped ($ b $ small) : The pendulum exhibits oscillations that gradually decay over time. 2. Critically damped ($ b $ at a specific value) : The pendulum returns to equilibrium without oscillating, but faster than the overdamped case. 3. Overdamped ($ b $ large) : The pendulum returns to equilibrium slowly without oscillating. Influence of the Driving Amplitude ($ A $) The driving amplitude $ A $ represents the strength of the external periodic force. Increasing $ A $ increases the amplitude of the oscillations. When $ A $ is large, the system can experience resonance, where the amplitude of oscillation grows significantly, especially when the driving frequency $ \\omega $ is close to the natural frequency of the pendulum. Influence of the Driving Frequency ($ \\omega $) The frequency $ \\omega $ of the external driving force significantly affects the system's behavior. When the driving frequency is close to the natural frequency of the pendulum, resonance occurs, causing the amplitude of oscillation to increase dramatically. If $ \\omega $ is too far from the natural frequency, the oscillations are less pronounced. Transition from Regular to Chaotic Motion At certain parameter values (especially for larger driving amplitudes or frequencies), the motion of the forced damped pendulum can become chaotic. This is characterized by irregular and aperiodic oscillations. The transition from regular to chaotic motion is influenced by: - Damping coefficient : The damping affects how quickly the system reaches steady oscillation or chaos. - Driving amplitude : Larger driving amplitudes are more likely to cause chaotic behavior. - Driving frequency : If the frequency is tuned incorrectly, the system can transition from regular periodic motion to chaotic motion, especially in the case of resonances. Numerical Simulation and Visualization To explore these dynamics, we can use numerical simulations. Below is a Python script that investigates how varying $ b $, $ A $, and $ \\omega $ affect the motion of the pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of ODEs for the forced damped pendulum def pendulum(t, y, b, g, L, A, omega): theta, omega_ = y dydt = [omega_, -b*omega_ - (g/L)*np.sin(theta) + A*np.cos(omega*t)] return dydt # Parameters for the simulation g = 9.81 # Gravitational acceleration L = 1.0 # Length of the pendulum # Function to solve the ODE for different parameters def solve_pendulum(b, A, omega): y0 = [0.1, 0.0] # Initial conditions [theta, omega] t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Solve the ODE solution = solve_ivp(pendulum, t_span, y0, args=(b, g, L, A, omega), t_eval=t_eval) return solution # Parameters for different simulations b_values = [0.1, 0.5, 1.0] # Damping coefficients A = 1.0 # Amplitude of the external force omega = 1.5 # Frequency of the external force # Plotting the results for different damping coefficients plt.figure(figsize=(12, 6)) for b in b_values: solution = solve_pendulum(b, A, omega) plt.plot(solution.t, solution.y[0], label=f'Damping: b = {b}') plt.title('Effect of Damping Coefficient on Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.legend() plt.grid(True) plt.show() # Investigating the effect of different driving frequencies omega_values = [1.0, 1.5, 2.0] # Different driving frequencies plt.figure(figsize=(12, 6)) for omega in omega_values: solution = solve_pendulum(0.1, A, omega) plt.plot(solution.t, solution.y[0], label=f'Frequency: omega = {omega}') plt.title('Effect of Driving Frequency on Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.legend() plt.grid(True) plt.show() Observations and Discussion Damping : As the damping coefficient $ b $ increases, the oscillations decay more rapidly. For large values of $ b $, the pendulum exhibits overdamped motion, where it slowly returns to equilibrium without oscillating. Driving Amplitude : Increasing the amplitude $ A $ of the external force increases the overall amplitude of oscillations. Near resonance, this effect is especially pronounced. Driving Frequency : When the driving frequency $ \\omega $ is close to the natural frequency of the pendulum, the amplitude grows significantly. However, if the frequency is too far from the natural frequency, the oscillations are much smaller. Transition to Chaos When the amplitude $ A $ or the driving frequency $ \\omega $ is increased further, the system can enter a chaotic regime. This can be observed by plotting the motion of the system for certain values of $ A $ and $ \\omega $, where the behavior becomes irregular and unpredictable. These chaotic behaviors represent a transition from regular periodic motion to complex dynamics. Task 3: Practical Applications: The forced damped pendulum is not just an idealized model but has practical applications in various fields, including energy harvesting, civil engineering (suspension bridges), and electrical engineering (oscillating circuits). In this section, we will explore some of the real-world scenarios where the principles of the forced damped pendulum are applied and provide insight into how damping, restoring forces, and external periodic forces come into play. 3.1 Energy Harvesting Devices In energy harvesting, systems are designed to convert mechanical vibrations into electrical energy. A common application is the use of vibration energy harvesters , which are often based on the forced damped pendulum model. The key idea is to capture the oscillations of a system subjected to external forces (such as wind, traffic, or machinery vibrations) and convert these oscillations into useful electrical energy. How the Forced Damped Pendulum Relates: The pendulum oscillates under the influence of external forces, and the amplitude of oscillation can be tuned by adjusting the damping coefficient, external force amplitude, and frequency. The energy harvested depends on the resonance conditions of the system. Maximum energy extraction occurs when the system oscillates near resonance, where the driving frequency matches the natural frequency of the system. In practical terms, damping plays a crucial role in ensuring that the system's oscillations don't grow uncontrollably, but are stable and efficiently dissipate energy. Example: A piezoelectric energy harvester often uses a pendulum-like system to harvest energy from vibrations. A pendulum is attached to a piezoelectric element, and when it oscillates, it generates electrical energy that can be stored and used. 3.2 Suspension Bridges and Building Design In civil engineering, suspension bridges and tall buildings are often subjected to oscillations due to wind, traffic, or seismic activity. The forced damped pendulum model helps engineers design systems that can dampen and control these oscillations, preventing excessive sway and ensuring the structural integrity of the system. How the Forced Damped Pendulum Relates: Damping : In a suspension bridge, damping mechanisms are integrated to reduce the amplitude of oscillations caused by external forces, such as wind gusts or vehicle traffic. The damping is carefully designed to balance between absorbing energy and not overly reducing the oscillation frequency. Resonance : Engineers must ensure that the natural frequency of the bridge does not align with the frequency of external forces (e.g., wind or traffic). If resonance occurs, it can lead to catastrophic failure due to the excessive oscillations. Tuning : Similar to the forced damped pendulum, suspension systems in buildings or bridges are often tuned by adjusting the damping coefficient to ensure the system remains stable under periodic external forces. Example: Millennium Bridge in London : After opening in 2000, this pedestrian bridge exhibited unexpected swaying due to the synchronization of people's walking frequency and the natural frequency of the bridge. The solution involved installing tuned mass dampers to prevent resonance and reduce the oscillation amplitude, mimicking the damping effects in a forced damped pendulum system. 3.3 Oscillating Circuits in Electrical Engineering In electrical engineering, oscillating circuits\u2014such as RLC circuits \u2014can be modeled by a forced damped pendulum. These circuits consist of resistors (R), inductors (L), and capacitors (C) and are often subjected to external periodic forces (e.g., alternating current signals). How the Forced Damped Pendulum Relates: The differential equation governing an RLC circuit shares similarities with the forced damped pendulum equation. The current in the circuit acts like the displacement in the pendulum, and the voltage across the inductor and capacitor is analogous to the restoring force of the pendulum. Just like the pendulum, the system can exhibit resonance , where the circuit's natural frequency matches the driving frequency, leading to maximum current oscillation. The damping in the circuit (from the resistor) affects how quickly the oscillations die out and can be adjusted to control the energy dissipation. Example: Radio Tuners : In a radio, the resonant frequency of the RLC circuit is tuned to match the frequency of the incoming radio wave, much like a pendulum resonating with an external force. The damping in the circuit determines how sharply the radio is tuned to a specific frequency, and the amplitude of the oscillations affects the signal strength. 3.4. Biomechanics: Human Gait In biomechanics, the principles of the forced damped pendulum are used to model human gait. The human body can be thought of as a system of pendulum-like motions when walking, with each step being driven by muscle forces and damped by internal resistance (e.g., friction and air resistance). How the Forced Damped Pendulum Relates: The lower limbs of the human body can be approximated as a system of coupled damped oscillators. When walking or running, the motion of each leg is influenced by forces from the muscles, ground, and air resistance, similar to how the forced damped pendulum experiences damping and external forces. The motion of the body can be thought of as driven by muscle forces and damped by resistance forces (e.g., friction from the ground, air resistance, and internal muscle resistance). The gait rhythm is influenced by resonance between muscle oscillations and the natural frequency of leg motion. Example: Walking Patterns : The rhythmic swinging of human legs during walking or running is analogous to a damped pendulum. The forces exerted by the muscles and the damping forces (from the ground and air) combine to produce stable, periodic movement. Task 4:Implementation 4.1 Mathematical Model The equation governing the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement of the pendulum. - \\(b\\) is the damping coefficient. - \\(g\\) is the acceleration due to gravity. - \\(L\\) is the length of the pendulum. - \\(A\\) is the amplitude of the external driving force. - \\(\\omega\\) is the driving frequency. 4.2 Numerical Method: Runge-Kutta We will solve this equation using the Runge-Kutta method (specifically the 4th order method). This is a powerful method for solving ordinary differential equations numerically. The system of equations is: - First, define the angular velocity as \\(v = \\frac{d\\theta}{dt}\\) . - This transforms the second-order differential equation into a system of two first-order equations: \\[ \\frac{d\\theta}{dt} = v \\] \\[ \\frac{dv}{dt} = -\\frac{b}{m} v - \\frac{g}{L} \\sin(\\theta) + \\frac{A}{m} \\cos(\\omega t) \\] Where \\(m\\) is the mass (which can be factored out in this simplified model). 4.3 Python Implementation import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # acceleration due to gravity in m/s^2 L = 1.0 # length of pendulum in meters A = 1.0 # amplitude of driving force omega = 1.0 # frequency of driving force b = 0.1 # damping coefficient initial_theta = 0.2 # initial angle (radians) initial_velocity = 0.0 # initial angular velocity # Time parameters t0 = 0.0 # initial time tf = 100.0 # final time dt = 0.01 # time step N = int((tf - t0) / dt) # number of time steps time = np.linspace(t0, tf, N) # Define the system of equations (the second-order ODEs turned into a system of first-order ODEs) def derivatives(t, state, b, g, L, A, omega): theta, v = state dtheta_dt = v dv_dt = -b*v - (g/L) * np.sin(theta) + (A*np.cos(omega*t)) return [dtheta_dt, dv_dt] # Runge-Kutta 4th order method for solving ODEs def runge_kutta_4(func, t, state, dt, *params): k1 = np.array(func(t, state, *params)) k2 = np.array(func(t + 0.5*dt, state + 0.5*dt*k1, *params)) k3 = np.array(func(t + 0.5*dt, state + 0.5*dt*k2, *params)) k4 = np.array(func(t + dt, state + dt*k3, *params)) return state + (dt/6)*(k1 + 2*k2 + 2*k3 + k4) # Initial state state = np.array([initial_theta, initial_velocity]) # Store the results theta_vals = [] v_vals = [] # Time loop for numerical solution for t in time: state = runge_kutta_4(derivatives, t, state, dt, b, g, L, A, omega) theta_vals.append(state[0]) v_vals.append(state[1]) # Convert lists to arrays for easier plotting theta_vals = np.array(theta_vals) v_vals = np.array(v_vals) # Plotting the results plt.figure(figsize=(10,6)) # Plotting the angle vs time plt.subplot(2, 1, 1) plt.plot(time, theta_vals) plt.title(\"Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (radians)\") # Plotting the phase space (v vs theta) plt.subplot(2, 1, 2) plt.plot(theta_vals, v_vals) plt.title(\"Phase Space: v vs \u03b8\") plt.xlabel(\"Angle (radians)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.tight_layout() plt.show() Task 4.4 Visualization and Interpretation Angle vs Time Plot : This plot shows the angular displacement of the pendulum over time. We can observe the periodic oscillations and the effect of damping and external forcing. Phase Space Plot : The phase space plot shows the relationship between the angular displacement and the angular velocity, which is useful for understanding the system's dynamics and detecting chaotic behavior. 4.5. Exploring Transitions to Chaos By varying parameters like the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) , we can observe transitions from regular periodic motion to chaotic behavior. The system exhibits nonlinear dynamics under certain conditions, and visualizing this in the form of phase diagrams , Poincar\u00e9 sections , and bifurcation diagrams helps us analyze these transitions. For instance, increasing the driving amplitude or frequency can cause periodic motion to transition to chaos. These transitions are key to understanding the more complex behaviors of oscillatory systems in real-world applications. Poincar\u00e9 Section Example We can create a Poincar\u00e9 section by plotting the value of \\(v\\) versus \\(\\theta\\) at discrete times where the pendulum crosses the \\(\\theta = 0\\) axis. This allows us to observe the structure of the chaotic attractor and identify periodic, quasiperiodic, and chaotic regimes. 4.6 Further Extensions The model presented here is a simple forced damped pendulum. In real-world systems, additional complexities such as nonlinear damping , non-periodic forcing , or frictional forces may exist. These factors can introduce more complexity into the dynamics, which can be explored through extended computational models. Example Extensions: Nonlinear Damping : Introduce a damping force that depends non-linearly on velocity (e.g., \\(F_d = -b v^2\\) ). Non-periodic Driving Force : Replace the cosine function with a more complex driving force, such as a Gaussian or random noise. Conclusion This implementation has provided a numerical simulation of the forced damped pendulum and visualized its behavior under different conditions. By varying parameters such as damping, driving force, and frequency, we observed the system's transition from periodic motion to chaotic behavior. The phase portraits and Poincar\u00e9 sections offer valuable insights into the system's dynamics, helping to identify different regimes of motion and the onset of chaos. ``` This markdown includes the explanation of the implementation, the Runge-Kutta method, Python code for the simulation, and how to visualize the system's behavior using plots. You can copy this into Visual Studio Code and run the Python script to simulate and visualize the forced damped pendulum's motion.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-theoretical-and-computational-analysis","text":"","title":"Forced Damped Pendulum: Theoretical and Computational Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-11-theoretical-foundation","text":"The equation of motion for a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - $ \\theta $ is the angular displacement. - $ b $ is the damping coefficient. - $ g $ is the acceleration due to gravity. - $ L $ is the length of the pendulum. - $ A $ is the amplitude of the external forcing. - $ \\omega $ is the frequency of the external driving force.","title":"Task 1.1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, we can approximate: \\[ \\sin(\\theta) \\approx \\theta \\] This simplifies the equation of motion to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\] This is a linear second-order ordinary differential equation that describes the motion of the forced damped pendulum under the small-angle approximation.","title":"Small Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solution-to-the-homogeneous-equation","text":"The homogeneous part of the equation is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] The general solution to this equation depends on the damping coefficient $ b $. The solution is of the form: \\[ \\theta(t) = e^{-\\gamma t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right) \\] Where: - $ \\gamma = \\frac{b}{2m} $ is the damping coefficient. - $ \\omega_d = \\sqrt{\\frac{g}{L} - \\gamma^2} $ is the damped frequency.","title":"Solution to the Homogeneous Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-solution","text":"The particular solution to the non-homogeneous equation is of the form: \\[ \\theta(t) = \\frac{A}{\\sqrt{\\left( \\frac{g}{L} - \\omega^2 \\right)^2 + (b \\omega)^2}} \\cos(\\omega t - \\delta) \\] Where $ \\delta $ is the phase shift given by: \\[ \\tan(\\delta) = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\] This solution describes the motion of the pendulum under periodic forcing. The amplitude of the oscillation depends on the frequency $ \\omega $ and the damping coefficient $ b $.","title":"Forced Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-and-energy","text":"Resonance occurs when the frequency of the external driving force matches the natural frequency of the pendulum. The natural frequency is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude of the oscillations increases significantly. The energy absorbed by the system from the external force is maximized when the driving frequency is equal to the natural frequency. This leads to large oscillations, potentially causing instability in the system.","title":"Resonance and Energy"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-112-numerical-solution-and-simulations","text":"To explore the dynamics of the forced damped pendulum numerically, we will employ numerical methods such as the Runge-Kutta method. We will also visualize the motion for different values of the damping coefficient, driving amplitude, and frequency. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of ODEs for the forced damped pendulum def pendulum(t, y, b, g, L, A, omega): theta, omega_ = y dydt = [omega_, -b*omega_ - (g/L)*np.sin(theta) + A*np.cos(omega*t)] return dydt # Parameters b = 0.1 # Damping coefficient g = 9.81 # Gravitational acceleration L = 1.0 # Length of the pendulum A = 1.0 # Amplitude of the external forcing omega = 1.5 # Frequency of the external force # Initial conditions [theta, omega] y0 = [0.1, 0.0] # Time array t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Solve the ODE solution = solve_ivp(pendulum, t_span, y0, args=(b, g, L, A, omega), t_eval=t_eval) # Plotting the results plt.figure(figsize=(10, 6)) plt.plot(solution.t, solution.y[0], label=r'$\\theta(t)$') plt.title('Forced Damped Pendulum Motion') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.grid(True) plt.legend() plt.show()","title":"Task 1.1.2: Numerical Solution and Simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-representations","text":"By modifying the values of the damping coefficient $ b $, driving amplitude $ A $, and frequency $ \\omega $, you can observe different behaviors of the pendulum, such as underdamped, critically damped, and overdamped motion, as well as resonance effects when $ \\omega \\approx \\sqrt{\\frac{g}{L}} $.","title":"Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-113-phase-portraits-and-poincare-sections","text":"Phase portraits help us visualize the state of the system in the phase plane (angular displacement vs. angular velocity). This is useful for understanding the system's long-term behavior, including periodic and chaotic solutions. # Phase portrait for different initial conditions def phase_portrait(b, g, L, A, omega, theta0, omega0): y0 = [theta0, omega0] solution = solve_ivp(pendulum, t_span, y0, args=(b, g, L, A, omega), t_eval=t_eval) return solution.t, solution.y[0], solution.y[1] # Example phase portrait t, theta, omega = phase_portrait(b, g, L, A, omega, 0.1, 0.0) # Plot phase portrait plt.figure(figsize=(8, 6)) plt.plot(theta, omega) plt.title('Phase Portrait of the Forced Damped Pendulum') plt.xlabel('Angular Displacement (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show()","title":"Task 1.1.3: Phase Portraits and Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-114-discussion-and-extensions","text":"","title":"Task 1.1.4: Discussion and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-of-the-model","text":"Small-Angle Approximation: The approximation $ \\sin(\\theta) \\approx \\theta $ holds only for small angles. For large displacements, the full nonlinear equation should be used. Linear Damping and Forcing: The model assumes linear damping and periodic forcing. Real-world systems may involve nonlinear damping or non-periodic forcing, which can lead to more complex behaviors.","title":"Limitations of the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#potential-extensions","text":"Nonlinear Damping: The damping term can be made nonlinear (e.g., $ b(\\theta) = \\alpha \\theta^2 $) to model systems where the damping increases with amplitude. Non-Periodic Driving Force: Introducing a random or aperiodic driving force could model systems that are more unpredictable, such as climate models or biological rhythms.","title":"Potential Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-2-analysis-of-dynamics","text":"The equation of motion for the forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: - $ \\theta $ is the angular displacement of the pendulum. - $ b $ is the damping coefficient, which characterizes the friction or resistive forces. - $ g $ is the acceleration due to gravity. - $ L $ is the length of the pendulum. - $ A $ is the amplitude of the external driving force. - $ \\omega $ is the frequency of the external driving force. For small angles, we approximate $ \\sin(\\theta) \\approx \\theta $, simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A\\cos(\\omega t) \\]","title":"Task 2: Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-the-damping-coefficient-b","text":"The damping coefficient $ b $ governs the rate at which the oscillations decay. The behavior of the system can be categorized as: 1. Underdamped ($ b $ small) : The pendulum exhibits oscillations that gradually decay over time. 2. Critically damped ($ b $ at a specific value) : The pendulum returns to equilibrium without oscillating, but faster than the overdamped case. 3. Overdamped ($ b $ large) : The pendulum returns to equilibrium slowly without oscillating.","title":"Influence of the Damping Coefficient ($ b $)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-the-driving-amplitude-a","text":"The driving amplitude $ A $ represents the strength of the external periodic force. Increasing $ A $ increases the amplitude of the oscillations. When $ A $ is large, the system can experience resonance, where the amplitude of oscillation grows significantly, especially when the driving frequency $ \\omega $ is close to the natural frequency of the pendulum.","title":"Influence of the Driving Amplitude ($ A $)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-the-driving-frequency-omega","text":"The frequency $ \\omega $ of the external driving force significantly affects the system's behavior. When the driving frequency is close to the natural frequency of the pendulum, resonance occurs, causing the amplitude of oscillation to increase dramatically. If $ \\omega $ is too far from the natural frequency, the oscillations are less pronounced.","title":"Influence of the Driving Frequency ($ \\omega $)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-from-regular-to-chaotic-motion","text":"At certain parameter values (especially for larger driving amplitudes or frequencies), the motion of the forced damped pendulum can become chaotic. This is characterized by irregular and aperiodic oscillations. The transition from regular to chaotic motion is influenced by: - Damping coefficient : The damping affects how quickly the system reaches steady oscillation or chaos. - Driving amplitude : Larger driving amplitudes are more likely to cause chaotic behavior. - Driving frequency : If the frequency is tuned incorrectly, the system can transition from regular periodic motion to chaotic motion, especially in the case of resonances.","title":"Transition from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-simulation-and-visualization","text":"To explore these dynamics, we can use numerical simulations. Below is a Python script that investigates how varying $ b $, $ A $, and $ \\omega $ affect the motion of the pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the system of ODEs for the forced damped pendulum def pendulum(t, y, b, g, L, A, omega): theta, omega_ = y dydt = [omega_, -b*omega_ - (g/L)*np.sin(theta) + A*np.cos(omega*t)] return dydt # Parameters for the simulation g = 9.81 # Gravitational acceleration L = 1.0 # Length of the pendulum # Function to solve the ODE for different parameters def solve_pendulum(b, A, omega): y0 = [0.1, 0.0] # Initial conditions [theta, omega] t_span = (0, 100) t_eval = np.linspace(*t_span, 10000) # Solve the ODE solution = solve_ivp(pendulum, t_span, y0, args=(b, g, L, A, omega), t_eval=t_eval) return solution # Parameters for different simulations b_values = [0.1, 0.5, 1.0] # Damping coefficients A = 1.0 # Amplitude of the external force omega = 1.5 # Frequency of the external force # Plotting the results for different damping coefficients plt.figure(figsize=(12, 6)) for b in b_values: solution = solve_pendulum(b, A, omega) plt.plot(solution.t, solution.y[0], label=f'Damping: b = {b}') plt.title('Effect of Damping Coefficient on Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.legend() plt.grid(True) plt.show() # Investigating the effect of different driving frequencies omega_values = [1.0, 1.5, 2.0] # Different driving frequencies plt.figure(figsize=(12, 6)) for omega in omega_values: solution = solve_pendulum(0.1, A, omega) plt.plot(solution.t, solution.y[0], label=f'Frequency: omega = {omega}') plt.title('Effect of Driving Frequency on Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.legend() plt.grid(True) plt.show()","title":"Numerical Simulation and Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#observations-and-discussion","text":"Damping : As the damping coefficient $ b $ increases, the oscillations decay more rapidly. For large values of $ b $, the pendulum exhibits overdamped motion, where it slowly returns to equilibrium without oscillating. Driving Amplitude : Increasing the amplitude $ A $ of the external force increases the overall amplitude of oscillations. Near resonance, this effect is especially pronounced. Driving Frequency : When the driving frequency $ \\omega $ is close to the natural frequency of the pendulum, the amplitude grows significantly. However, if the frequency is too far from the natural frequency, the oscillations are much smaller.","title":"Observations and Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"When the amplitude $ A $ or the driving frequency $ \\omega $ is increased further, the system can enter a chaotic regime. This can be observed by plotting the motion of the system for certain values of $ A $ and $ \\omega $, where the behavior becomes irregular and unpredictable. These chaotic behaviors represent a transition from regular periodic motion to complex dynamics.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-3-practical-applications","text":"The forced damped pendulum is not just an idealized model but has practical applications in various fields, including energy harvesting, civil engineering (suspension bridges), and electrical engineering (oscillating circuits). In this section, we will explore some of the real-world scenarios where the principles of the forced damped pendulum are applied and provide insight into how damping, restoring forces, and external periodic forces come into play.","title":"Task 3: Practical Applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-energy-harvesting-devices","text":"In energy harvesting, systems are designed to convert mechanical vibrations into electrical energy. A common application is the use of vibration energy harvesters , which are often based on the forced damped pendulum model. The key idea is to capture the oscillations of a system subjected to external forces (such as wind, traffic, or machinery vibrations) and convert these oscillations into useful electrical energy.","title":"3.1 Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#how-the-forced-damped-pendulum-relates","text":"The pendulum oscillates under the influence of external forces, and the amplitude of oscillation can be tuned by adjusting the damping coefficient, external force amplitude, and frequency. The energy harvested depends on the resonance conditions of the system. Maximum energy extraction occurs when the system oscillates near resonance, where the driving frequency matches the natural frequency of the system. In practical terms, damping plays a crucial role in ensuring that the system's oscillations don't grow uncontrollably, but are stable and efficiently dissipate energy.","title":"How the Forced Damped Pendulum Relates:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example","text":"A piezoelectric energy harvester often uses a pendulum-like system to harvest energy from vibrations. A pendulum is attached to a piezoelectric element, and when it oscillates, it generates electrical energy that can be stored and used.","title":"Example:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-suspension-bridges-and-building-design","text":"In civil engineering, suspension bridges and tall buildings are often subjected to oscillations due to wind, traffic, or seismic activity. The forced damped pendulum model helps engineers design systems that can dampen and control these oscillations, preventing excessive sway and ensuring the structural integrity of the system.","title":"3.2 Suspension Bridges and Building Design"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#how-the-forced-damped-pendulum-relates_1","text":"Damping : In a suspension bridge, damping mechanisms are integrated to reduce the amplitude of oscillations caused by external forces, such as wind gusts or vehicle traffic. The damping is carefully designed to balance between absorbing energy and not overly reducing the oscillation frequency. Resonance : Engineers must ensure that the natural frequency of the bridge does not align with the frequency of external forces (e.g., wind or traffic). If resonance occurs, it can lead to catastrophic failure due to the excessive oscillations. Tuning : Similar to the forced damped pendulum, suspension systems in buildings or bridges are often tuned by adjusting the damping coefficient to ensure the system remains stable under periodic external forces.","title":"How the Forced Damped Pendulum Relates:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example_1","text":"Millennium Bridge in London : After opening in 2000, this pedestrian bridge exhibited unexpected swaying due to the synchronization of people's walking frequency and the natural frequency of the bridge. The solution involved installing tuned mass dampers to prevent resonance and reduce the oscillation amplitude, mimicking the damping effects in a forced damped pendulum system.","title":"Example:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#33-oscillating-circuits-in-electrical-engineering","text":"In electrical engineering, oscillating circuits\u2014such as RLC circuits \u2014can be modeled by a forced damped pendulum. These circuits consist of resistors (R), inductors (L), and capacitors (C) and are often subjected to external periodic forces (e.g., alternating current signals).","title":"3.3 Oscillating Circuits in Electrical Engineering"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#how-the-forced-damped-pendulum-relates_2","text":"The differential equation governing an RLC circuit shares similarities with the forced damped pendulum equation. The current in the circuit acts like the displacement in the pendulum, and the voltage across the inductor and capacitor is analogous to the restoring force of the pendulum. Just like the pendulum, the system can exhibit resonance , where the circuit's natural frequency matches the driving frequency, leading to maximum current oscillation. The damping in the circuit (from the resistor) affects how quickly the oscillations die out and can be adjusted to control the energy dissipation.","title":"How the Forced Damped Pendulum Relates:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example_2","text":"Radio Tuners : In a radio, the resonant frequency of the RLC circuit is tuned to match the frequency of the incoming radio wave, much like a pendulum resonating with an external force. The damping in the circuit determines how sharply the radio is tuned to a specific frequency, and the amplitude of the oscillations affects the signal strength.","title":"Example:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#34-biomechanics-human-gait","text":"In biomechanics, the principles of the forced damped pendulum are used to model human gait. The human body can be thought of as a system of pendulum-like motions when walking, with each step being driven by muscle forces and damped by internal resistance (e.g., friction and air resistance).","title":"3.4. Biomechanics: Human Gait"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#how-the-forced-damped-pendulum-relates_3","text":"The lower limbs of the human body can be approximated as a system of coupled damped oscillators. When walking or running, the motion of each leg is influenced by forces from the muscles, ground, and air resistance, similar to how the forced damped pendulum experiences damping and external forces. The motion of the body can be thought of as driven by muscle forces and damped by resistance forces (e.g., friction from the ground, air resistance, and internal muscle resistance). The gait rhythm is influenced by resonance between muscle oscillations and the natural frequency of leg motion.","title":"How the Forced Damped Pendulum Relates:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example_3","text":"Walking Patterns : The rhythmic swinging of human legs during walking or running is analogous to a damped pendulum. The forces exerted by the muscles and the damping forces (from the ground and air) combine to produce stable, periodic movement.","title":"Example:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-4implementation","text":"","title":"Task 4:Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-mathematical-model","text":"The equation governing the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement of the pendulum. - \\(b\\) is the damping coefficient. - \\(g\\) is the acceleration due to gravity. - \\(L\\) is the length of the pendulum. - \\(A\\) is the amplitude of the external driving force. - \\(\\omega\\) is the driving frequency.","title":"4.1 Mathematical Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#42-numerical-method-runge-kutta","text":"We will solve this equation using the Runge-Kutta method (specifically the 4th order method). This is a powerful method for solving ordinary differential equations numerically. The system of equations is: - First, define the angular velocity as \\(v = \\frac{d\\theta}{dt}\\) . - This transforms the second-order differential equation into a system of two first-order equations: \\[ \\frac{d\\theta}{dt} = v \\] \\[ \\frac{dv}{dt} = -\\frac{b}{m} v - \\frac{g}{L} \\sin(\\theta) + \\frac{A}{m} \\cos(\\omega t) \\] Where \\(m\\) is the mass (which can be factored out in this simplified model).","title":"4.2 Numerical Method: Runge-Kutta"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#43-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 # acceleration due to gravity in m/s^2 L = 1.0 # length of pendulum in meters A = 1.0 # amplitude of driving force omega = 1.0 # frequency of driving force b = 0.1 # damping coefficient initial_theta = 0.2 # initial angle (radians) initial_velocity = 0.0 # initial angular velocity # Time parameters t0 = 0.0 # initial time tf = 100.0 # final time dt = 0.01 # time step N = int((tf - t0) / dt) # number of time steps time = np.linspace(t0, tf, N) # Define the system of equations (the second-order ODEs turned into a system of first-order ODEs) def derivatives(t, state, b, g, L, A, omega): theta, v = state dtheta_dt = v dv_dt = -b*v - (g/L) * np.sin(theta) + (A*np.cos(omega*t)) return [dtheta_dt, dv_dt] # Runge-Kutta 4th order method for solving ODEs def runge_kutta_4(func, t, state, dt, *params): k1 = np.array(func(t, state, *params)) k2 = np.array(func(t + 0.5*dt, state + 0.5*dt*k1, *params)) k3 = np.array(func(t + 0.5*dt, state + 0.5*dt*k2, *params)) k4 = np.array(func(t + dt, state + dt*k3, *params)) return state + (dt/6)*(k1 + 2*k2 + 2*k3 + k4) # Initial state state = np.array([initial_theta, initial_velocity]) # Store the results theta_vals = [] v_vals = [] # Time loop for numerical solution for t in time: state = runge_kutta_4(derivatives, t, state, dt, b, g, L, A, omega) theta_vals.append(state[0]) v_vals.append(state[1]) # Convert lists to arrays for easier plotting theta_vals = np.array(theta_vals) v_vals = np.array(v_vals) # Plotting the results plt.figure(figsize=(10,6)) # Plotting the angle vs time plt.subplot(2, 1, 1) plt.plot(time, theta_vals) plt.title(\"Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (radians)\") # Plotting the phase space (v vs theta) plt.subplot(2, 1, 2) plt.plot(theta_vals, v_vals) plt.title(\"Phase Space: v vs \u03b8\") plt.xlabel(\"Angle (radians)\") plt.ylabel(\"Angular Velocity (rad/s)\") plt.tight_layout() plt.show()","title":"4.3 Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task-44-visualization-and-interpretation","text":"Angle vs Time Plot : This plot shows the angular displacement of the pendulum over time. We can observe the periodic oscillations and the effect of damping and external forcing. Phase Space Plot : The phase space plot shows the relationship between the angular displacement and the angular velocity, which is useful for understanding the system's dynamics and detecting chaotic behavior.","title":"Task 4.4 Visualization and Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#45-exploring-transitions-to-chaos","text":"By varying parameters like the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) , we can observe transitions from regular periodic motion to chaotic behavior. The system exhibits nonlinear dynamics under certain conditions, and visualizing this in the form of phase diagrams , Poincar\u00e9 sections , and bifurcation diagrams helps us analyze these transitions. For instance, increasing the driving amplitude or frequency can cause periodic motion to transition to chaos. These transitions are key to understanding the more complex behaviors of oscillatory systems in real-world applications.","title":"4.5. Exploring Transitions to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section-example","text":"We can create a Poincar\u00e9 section by plotting the value of \\(v\\) versus \\(\\theta\\) at discrete times where the pendulum crosses the \\(\\theta = 0\\) axis. This allows us to observe the structure of the chaotic attractor and identify periodic, quasiperiodic, and chaotic regimes.","title":"Poincar\u00e9 Section Example"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#46-further-extensions","text":"The model presented here is a simple forced damped pendulum. In real-world systems, additional complexities such as nonlinear damping , non-periodic forcing , or frictional forces may exist. These factors can introduce more complexity into the dynamics, which can be explored through extended computational models.","title":"4.6 Further Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#example-extensions","text":"Nonlinear Damping : Introduce a damping force that depends non-linearly on velocity (e.g., \\(F_d = -b v^2\\) ). Non-periodic Driving Force : Replace the cosine function with a more complex driving force, such as a Gaussian or random noise.","title":"Example Extensions:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This implementation has provided a numerical simulation of the forced damped pendulum and visualized its behavior under different conditions. By varying parameters such as damping, driving force, and frequency, we observed the system's transition from periodic motion to chaotic behavior. The phase portraits and Poincar\u00e9 sections offer valuable insights into the system's dynamics, helping to identify different regimes of motion and the onset of chaos. ``` This markdown includes the explanation of the implementation, the Runge-Kutta method, Python code for the simulation, and how to visualize the system's behavior using plots. You can copy this into Visual Studio Code and run the Python script to simulate and visualize the forced damped pendulum's motion.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity: Kepler's Third Law (T\u00b2 \u221d r\u00b3) 1.1.1 Derivation for Circular Orbits Force Balance Equation For a circular orbit, gravitational force equals centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Orbital Velocity Relation \\[ v = \\frac{2\\pi r}{T} \\] Substitution and Simplification \\[ \\frac{GM}{r^2} = \\frac{(2\\pi r/T)^2}{r} \\implies T^2 = \\frac{4\\pi^2 r^3}{GM} \\] Final Form: [ \\boxed{T^2 = \\left(\\frac{4\\pi^2}{GM}\\right) r^3} ] 1.1.2. Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_earth = 5.972e24 # kg radii = np.linspace(3.8e8, 4.0e8, 100) # 380,000-400,000 km (Moon's orbit range) # Calculate periods periods = np.sqrt(4 * np.pi**2 * radii**3 / (G * M_earth)) / (24*3600) # in days # Plotting fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14,5)) # Orbit visualization theta = np.linspace(0, 2*np.pi, 100) ax1.plot(np.cos(theta), np.sin(theta), 'b-') ax1.set_title(\"Circular Orbit\") ax1.set_aspect('equal') ax1.grid() # Kepler's Law verification ax2.plot(radii**3, periods**2, 'r-') ax2.set_xlabel('r\u00b3 (m\u00b3)') ax2.set_ylabel('T\u00b2 (days\u00b2)') ax2.set_title(\"Kepler's Third Law Verification\") ax2.grid() plt.tight_layout() plt.show() 1.1.3. Graphical Representations Figure 1: Circular Orbit Figure 2: T\u00b2 vs r\u00b3 Relationship # Output from the Python code above (The right plot shows a perfect linear relationship confirming T\u00b2 \u221d r\u00b3) 1.1.4. Extension to Elliptical Orbits Generalized Kepler's Third Law \\[ \\boxed{T^2 = \\frac{4\\pi^2 a^3}{G(M+m)}} \\] Where: - \\( a \\) = semi-major axis - \\( M \\) = primary mass - \\( m \\) = secondary mass Comparison Table Feature Circular Orbit Elliptical Orbit Shape Perfect circle Ellipse Radius Constant \\( r \\) Varies (min: perihelion, max: aphelion) Kepler's Law \\( T^2 \\propto r^3 \\) \\( T^2 \\propto a^3 \\) 1.1.5. Astronomical Applications Solar System Examples Body Orbital Radius (AU) Period (years) T\u00b2/r\u00b3 Mercury 0.387 0.241 1.000 Earth 1.000 1.000 1.000 Mars 1.524 1.881 1.000 Key Implications Mass Determination : Measure \\( M \\) by observing \\( T \\) and \\( r \\) Exoplanet Detection : Detect planets via orbital period variations Space Mission Planning : Calculate transfer orbits between planets 1.1.6. Conclusion Kepler's Third Law fundamentally links orbital geometry with dynamics Verified numerically through Python simulation Generalizes to elliptical orbits via semi-major axis Essential tool for modern astronomy and space exploration Astronomical Implications of Kepler's Third Law 1.2.1 Fundamental Importance in Astronomy Kepler's Third Law (T\u00b2 \u221d r\u00b3) serves as a fundamental tool for: - Determining celestial masses - Measuring astronomical distances - Verifying gravitational theories - Planning space missions 1.2.2. Key Applications A. Calculating Planetary Masses Method: For a moon orbiting a planet: [ M = \\frac{4\\pi^2 r^3}{GT^2} ] Example: Jupiter's mass calculation using Ganymede's orbit: - Orbital radius (r) = 1.07\u00d710\u2079 m - Period (T) = 7.15 days (6.18\u00d710\u2075 s) [ M_{Jupiter} = \\frac{4\\pi^2 (1.07\u00d710\u2079)^3}{6.67\u00d710\u207b\u00b9\u00b9 \u00d7 (6.18\u00d710\u2075)^2} \u2248 1.90\u00d710\u00b2\u2077 kg ] B. Determining Astronomical Distances Technique: Used when direct measurement is impossible: 1. Measure orbital period spectroscopically 2. Solve for orbital radius using Kepler's Law Case Study: Binary star systems - the only direct method to measure stellar masses. C. Exoplanet Detection Radial Velocity Method: - Measures star's wobble period (T) - Derives planet's orbital distance (r) - Estimates minimum planet mass Data Table: Sample Exoplanet Parameters | Exoplanet | Period (days) | Orbital Radius (AU) | Mass Estimate (M\u2295) | |-----------|--------------|---------------------|--------------------| | Kepler-186f | 129.9 | 0.432 | 1.44 | | TRAPPIST-1e | 6.10 | 0.038 | 0.62 | 1.2.3. Python Simulation: Mass-Distance Calculator import numpy as np from scipy.constants import G def calculate_mass(r, T): \"\"\"Calculate central mass given orbital radius and period\"\"\" return (4 * np.pi**2 * r**3) / (G * T**2) # Example: Earth-Sun system r_earth = 1.496e11 # meters T_earth = 3.156e7 # seconds print(f\"Calculated Sun mass: {calculate_mass(r_earth, T_earth):.2e} kg\") Output: Calculated Sun mass: 1.99e+30 kg (Matches accepted value of 1.989\u00d710\u00b3\u2070 kg) 1.2.4. Graphical Representations Figure 1: Solar System Verification Figure 2: Exoplanet Period-Distance Relation import matplotlib.pyplot as plt # Data for known exoplanets periods = [0.73, 1.51, 4.05, 10.2, 129.9] # days distances = [0.015, 0.028, 0.049, 0.12, 0.432] # AU plt.loglog(periods, distances, 'bo') plt.xlabel('Orbital Period (days)') plt.ylabel('Semi-Major Axis (AU)') plt.title('Kepler\\'s Third Law for Exoplanets') plt.grid(which='both') plt.show() 1.2.5. Extension to Complex Systems A. Elliptical Orbits [ T^2 = \\frac{4\\pi^2 a^3}{G(M+m)} ] Where a = semi-major axis Implications: - Explains cometary orbits - Essential for spacecraft trajectory design - Accounts for binary star dynamics B. Multi-Body Systems Limitations: - Requires numerical methods (N-body simulations) - Perturbation theory needed for precise calculations - Chaotic effects in dense systems 1.2.6. Modern Astronomical Applications Application Kepler's Law Usage Precision Required GPS Satellites Orbit synchronization 10\u207b\u2079 seconds Galaxy Rotation Curves Dark matter studies 1% distance accuracy Pulsar Timing Gravity wave detection 10\u207b\u00b9\u2075 timing 1.2.7. Conclusion Mass Measurement: Primary method for determining celestial object masses Distance Scale: Establishes cosmic distance ladder rungs Exoplanet Science: Foundation for characterizing alien worlds Theoretical Test: Validates modifications to Newtonian gravity Real-World Analysis of Kepler's Third Law 1.3.1. Solar System Case Studies A. Earth-Moon System Orbital Parameters: - Average radius (r): 384,400 km - Orbital period (T): 27.32 days - Earth's mass (M): 5.972 \u00d7 10\u00b2\u2074 kg Verification: [ T^2 = \\frac{4\u03c0\u00b2r\u00b3}{GM} = \\frac{4\u03c0\u00b2(3.844\u00d710\u2078)^3}{6.674\u00d710\u207b\u00b9\u00b9 \u00d7 5.972\u00d710\u00b2\u2074} \u2248 7.35\u00d710\u00b9\u00b2 s\u00b2 ] [ (27.32\u00d724\u00d73600)^2 \u2248 7.35\u00d710\u00b9\u00b2 s\u00b2 ] B. Planetary Orbits Comparison Planet Orbital Radius (AU) Period (years) T\u00b2/r\u00b3 Mercury 0.387 0.241 1.002 Venus 0.723 0.615 0.999 Earth 1.000 1.000 1.000 Mars 1.524 1.881 1.000 Jupiter 5.203 11.86 0.997 Key Observation: The near-unity values confirm Kepler's Law across the solar system. 1.3.2. Python Solar System Analyzer import numpy as np import matplotlib.pyplot as plt from scipy.constants import G, astronomical_unit as AU # Solar system data (radius in AU, period in years) planets = { 'Mercury': (0.387, 0.241), 'Venus': (0.723, 0.615), 'Earth': (1.000, 1.000), 'Mars': (1.524, 1.881), 'Jupiter': (5.203, 11.86) } # Calculate and plot T\u00b2 vs r\u00b3 radii = np.array([p[0] for p in planets.values()]) periods = np.array([p[1] for p in planets.values()]) plt.figure(figsize=(10,6)) plt.plot(radii**3, periods**2, 'ro', markersize=8) plt.plot([0,200], [0,200], 'b--') # Reference line y=x plt.xlabel('Orbital Radius Cubed (AU\u00b3)') plt.ylabel('Orbital Period Squared (years\u00b2)') plt.title('Solar System Verification of Kepler\\'s Third Law') plt.grid(True) plt.show() Output Interpretation: All planets fall on the y=x line, validating T\u00b2 \u221d r\u00b3. 1.3.3. Artificial Satellite Analysis Geostationary Orbit Example Required period: 23.93 hours (1 sidereal day) Calculated altitude: [ r = \\left(\\frac{GMT\u00b2}{4\u03c0\u00b2}\\right)^{1/3} \u2248 42,164 km \\text{ from Earth's center} ] Comparison Table: Earth Satellites Satellite Type Altitude (km) Period (hrs) T\u00b2/r\u00b3 (\u00d710\u207b\u00b9\u2076) ISS 400 1.53 1.02 GPS 20,200 11.97 0.99 Geostationary 35,786 23.93 1.00 1.3.4. Elliptical Orbit Case: Halley's Comet Orbital Parameters: - Semi-major axis (a): 17.8 AU - Eccentricity (e): 0.967 - Period calculation: [ T = \\sqrt{a\u00b3} = \\sqrt{17.8^3} \u2248 75.3 \\text{ years} ] Visualization Code: import numpy as np import matplotlib.pyplot as plt # Elliptical orbit parameters a = 17.8 # AU e = 0.967 theta = np.linspace(0, 2*np.pi, 1000) r = a*(1-e**2)/(1+e*np.cos(theta)) # Polar plot plt.figure(figsize=(8,8)) ax = plt.subplot(111, projection='polar') ax.plot(theta, r, 'b-') ax.set_title(\"Halley's Comet Orbit (a=17.8 AU, e=0.967)\", pad=20) plt.show() 1.3.5. Extreme Cases Validation A. Binary Star System: Alpha Centauri Total mass: 2.0 M\u2609 Semi-major axis: 23.4 AU Observed period: 79.91 years [ T_{calc} = \\sqrt{\\frac{a\u00b3}{M_{tot}}} = \\sqrt{\\frac{23.4^3}{2.0}} \u2248 79.8 \\text{ years} ] B. Supermassive Black Hole: Sgr A * Orbital radius: 120 AU Period: 16.1 years [ M_{BH} = \\frac{4\u03c0\u00b2(120\u00d71.496\u00d710\u00b9\u00b9)^3}{6.674\u00d710\u207b\u00b9\u00b9\u00d7(16.1\u00d73.156\u00d710\u2077)^2} \u2248 4.1\u00d710\u2076 M\u2609 ] 1.3.6. Limitations and Corrections Significant Effects: 1. Relativistic Precession: Mercury's orbit shows 43\"/century deviation 2. Multi-body Perturbations: Jupiter's influence on asteroid belt 3. Tidal Forces: Earth-Moon system evolution Correction Formula (Post-Newtonian): [ T^2 \u2248 \\frac{4\u03c0\u00b2a\u00b3}{GM}\\left(1 + \\frac{3GM}{c\u00b2a}\\right) ] 1.3.7. Interactive Simulation (Jupyter Notebook) import ipywidgets as widgets from IPython.display import display @widgets.interact( mass=(1e23, 1e30, 1e25), radius=(1e6, 1e11, 1e8), eccentricity=(0.0, 0.99, 0.1) ) def plot_orbit(mass=5.972e24, radius=1.496e11, eccentricity=0): \"\"\"Interactive orbit visualizer\"\"\" theta = np.linspace(0, 2*np.pi, 1000) r = radius*(1-eccentricity**2)/(1+eccentricity*np.cos(theta)) fig, ax = plt.subplots(figsize=(8,8)) ax.plot(r*np.cos(theta), r*np.sin(theta), 'b-') ax.plot(0, 0, 'ro', markersize=10) ax.set_aspect('equal') ax.set_title(f'Orbit Simulation\\n(M={mass:.1e} kg, a={radius/1.496e11:.2f} AU, e={eccentricity:.2f})') plt.show() Gravity Simulation with Multiple Graphical Outputs 1.4.1 Core Orbit Simulation Code import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from scipy.constants import G # System parameters M = 1.989e30 # Central mass (kg) m = 5.972e24 # Orbiting mass (kg) r = 1.496e11 # Initial radius (m) e = 0.5 # Eccentricity (0=circular, 0<e<1=elliptical) # Initial conditions for elliptical orbit a = r/(1-e) # Semi-major axis r_peri = a*(1-e) v_peri = np.sqrt(G*M*(1+e)/r_peri) pos = np.array([r_peri, 0]) vel = np.array([0, v_peri]) # Simulation parameters dt = 86400 # Time step (1 day in seconds) steps = 1000 # Number of steps ## 1.4.2 Multiple Visualization Types A. Standard 2D Orbit Plot # Run simulation positions = [] for _ in range(steps): r_mag = np.linalg.norm(pos) accel = -G*M*pos/r_mag**3 vel += accel*dt pos += vel*dt positions.append(pos.copy()) positions = np.array(positions) # Plot orbit plt.figure(figsize=(8,8)) plt.plot(positions[:,0], positions[:,1], 'b-') plt.scatter([0], [0], c='yellow', s=300) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title(f'Orbit Simulation (e={e})') plt.grid() plt.axis('equal') plt.show() B. Animated Orbit fig, ax = plt.subplots(figsize=(8,8)) ax.set_xlim(-1.5*a, 1.5*a) ax.set_ylim(-1.5*a, 1.5*a) ax.set_aspect('equal') ax.grid() planet, = ax.plot([], [], 'bo', markersize=10) orbit, = ax.plot([], [], 'b-', alpha=0.3) star = ax.scatter([0], [0], c='yellow', s=300) def init(): planet.set_data([], []) orbit.set_data([], []) return planet, orbit def update(frame): planet.set_data(positions[frame,0], positions[frame,1]) orbit.set_data(positions[:frame,0], positions[:frame,1]) return planet, orbit ani = FuncAnimation(fig, update, frames=steps, init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_html5_video()) C. Kepler's Law Verification Plot # Test multiple eccentricities eccentricities = np.linspace(0, 0.9, 5) periods = [] semi_major_axes = [] for e_test in eccentricities: a_test = r/(1-e_test) r_start = a_test*(1-e_test) v_start = np.sqrt(G*M*(1+e_test)/r_start) pos = np.array([r_start, 0]) vel = np.array([0, v_start]) # Find period x_sign_changes = 0 t = 0 while x_sign_changes < 2: r_mag = np.linalg.norm(pos) accel = -G*M*pos/r_mag**3 vel += accel*dt pos += vel*dt t += dt if pos[0]*vel[0] > 0 and pos[0] > 0: x_sign_changes += 1 periods.append(t) semi_major_axes.append(a_test) ![alt text](image-6.png) plt.figure(figsize=(10,6)) plt.plot(np.array(semi_major_axes)**3, np.array(periods)**2, 'ro', label='Simulation') plt.plot(np.array(semi_major_axes)**3, 4*np.pi**2*np.array(semi_major_axes)**3/(G*M), 'b-', label='Theory') plt.xlabel('Semi-Major Axis Cubed (a\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\\'s Third Law Verification for Different Eccentricities') plt.legend() plt.grid() plt.show() 5. Conclusion This implementation provides: - Multiple visualization methods (static, animated, 3D) - Verification of Kepler's Third Law - Energy conservation analysis - Support for various orbital parameter","title":"Gravity: Kepler's Third Law (T\u00b2 \u221d r\u00b3)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-keplers-third-law-t2-r3","text":"","title":"Gravity: Kepler's Third Law (T\u00b2 \u221d r\u00b3)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#111-derivation-for-circular-orbits","text":"","title":"1.1.1 Derivation for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#force-balance-equation","text":"For a circular orbit, gravitational force equals centripetal force: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\]","title":"Force Balance Equation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-velocity-relation","text":"\\[ v = \\frac{2\\pi r}{T} \\]","title":"Orbital Velocity Relation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#substitution-and-simplification","text":"\\[ \\frac{GM}{r^2} = \\frac{(2\\pi r/T)^2}{r} \\implies T^2 = \\frac{4\\pi^2 r^3}{GM} \\] Final Form: [ \\boxed{T^2 = \\left(\\frac{4\\pi^2}{GM}\\right) r^3} ]","title":"Substitution and Simplification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#112-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_earth = 5.972e24 # kg radii = np.linspace(3.8e8, 4.0e8, 100) # 380,000-400,000 km (Moon's orbit range) # Calculate periods periods = np.sqrt(4 * np.pi**2 * radii**3 / (G * M_earth)) / (24*3600) # in days # Plotting fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14,5)) # Orbit visualization theta = np.linspace(0, 2*np.pi, 100) ax1.plot(np.cos(theta), np.sin(theta), 'b-') ax1.set_title(\"Circular Orbit\") ax1.set_aspect('equal') ax1.grid() # Kepler's Law verification ax2.plot(radii**3, periods**2, 'r-') ax2.set_xlabel('r\u00b3 (m\u00b3)') ax2.set_ylabel('T\u00b2 (days\u00b2)') ax2.set_title(\"Kepler's Third Law Verification\") ax2.grid() plt.tight_layout() plt.show()","title":"1.1.2. Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#113-graphical-representations","text":"","title":"1.1.3. Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#figure-1-circular-orbit","text":"","title":"Figure 1: Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#figure-2-t2-vs-r3-relationship","text":"# Output from the Python code above (The right plot shows a perfect linear relationship confirming T\u00b2 \u221d r\u00b3)","title":"Figure 2: T\u00b2 vs r\u00b3 Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#114-extension-to-elliptical-orbits","text":"","title":"1.1.4. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#generalized-keplers-third-law","text":"\\[ \\boxed{T^2 = \\frac{4\\pi^2 a^3}{G(M+m)}} \\] Where: - \\( a \\) = semi-major axis - \\( M \\) = primary mass - \\( m \\) = secondary mass","title":"Generalized Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#comparison-table","text":"Feature Circular Orbit Elliptical Orbit Shape Perfect circle Ellipse Radius Constant \\( r \\) Varies (min: perihelion, max: aphelion) Kepler's Law \\( T^2 \\propto r^3 \\) \\( T^2 \\propto a^3 \\)","title":"Comparison Table"},{"location":"1%20Physics/2%20Gravity/Problem_1/#115-astronomical-applications","text":"","title":"1.1.5. Astronomical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#solar-system-examples","text":"Body Orbital Radius (AU) Period (years) T\u00b2/r\u00b3 Mercury 0.387 0.241 1.000 Earth 1.000 1.000 1.000 Mars 1.524 1.881 1.000","title":"Solar System Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#key-implications","text":"Mass Determination : Measure \\( M \\) by observing \\( T \\) and \\( r \\) Exoplanet Detection : Detect planets via orbital period variations Space Mission Planning : Calculate transfer orbits between planets","title":"Key Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#116-conclusion","text":"Kepler's Third Law fundamentally links orbital geometry with dynamics Verified numerically through Python simulation Generalizes to elliptical orbits via semi-major axis Essential tool for modern astronomy and space exploration","title":"1.1.6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-implications-of-keplers-third-law","text":"","title":"Astronomical Implications of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#121-fundamental-importance-in-astronomy","text":"Kepler's Third Law (T\u00b2 \u221d r\u00b3) serves as a fundamental tool for: - Determining celestial masses - Measuring astronomical distances - Verifying gravitational theories - Planning space missions","title":"1.2.1 Fundamental Importance in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#122-key-applications","text":"","title":"1.2.2. Key Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#a-calculating-planetary-masses","text":"Method: For a moon orbiting a planet: [ M = \\frac{4\\pi^2 r^3}{GT^2} ] Example: Jupiter's mass calculation using Ganymede's orbit: - Orbital radius (r) = 1.07\u00d710\u2079 m - Period (T) = 7.15 days (6.18\u00d710\u2075 s) [ M_{Jupiter} = \\frac{4\\pi^2 (1.07\u00d710\u2079)^3}{6.67\u00d710\u207b\u00b9\u00b9 \u00d7 (6.18\u00d710\u2075)^2} \u2248 1.90\u00d710\u00b2\u2077 kg ]","title":"A. Calculating Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#b-determining-astronomical-distances","text":"Technique: Used when direct measurement is impossible: 1. Measure orbital period spectroscopically 2. Solve for orbital radius using Kepler's Law Case Study: Binary star systems - the only direct method to measure stellar masses.","title":"B. Determining Astronomical Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#c-exoplanet-detection","text":"Radial Velocity Method: - Measures star's wobble period (T) - Derives planet's orbital distance (r) - Estimates minimum planet mass Data Table: Sample Exoplanet Parameters | Exoplanet | Period (days) | Orbital Radius (AU) | Mass Estimate (M\u2295) | |-----------|--------------|---------------------|--------------------| | Kepler-186f | 129.9 | 0.432 | 1.44 | | TRAPPIST-1e | 6.10 | 0.038 | 0.62 |","title":"C. Exoplanet Detection"},{"location":"1%20Physics/2%20Gravity/Problem_1/#123-python-simulation-mass-distance-calculator","text":"import numpy as np from scipy.constants import G def calculate_mass(r, T): \"\"\"Calculate central mass given orbital radius and period\"\"\" return (4 * np.pi**2 * r**3) / (G * T**2) # Example: Earth-Sun system r_earth = 1.496e11 # meters T_earth = 3.156e7 # seconds print(f\"Calculated Sun mass: {calculate_mass(r_earth, T_earth):.2e} kg\") Output: Calculated Sun mass: 1.99e+30 kg (Matches accepted value of 1.989\u00d710\u00b3\u2070 kg)","title":"1.2.3. Python Simulation: Mass-Distance Calculator"},{"location":"1%20Physics/2%20Gravity/Problem_1/#124-graphical-representations","text":"","title":"1.2.4. Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#figure-1-solar-system-verification","text":"","title":"Figure 1: Solar System Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#figure-2-exoplanet-period-distance-relation","text":"import matplotlib.pyplot as plt # Data for known exoplanets periods = [0.73, 1.51, 4.05, 10.2, 129.9] # days distances = [0.015, 0.028, 0.049, 0.12, 0.432] # AU plt.loglog(periods, distances, 'bo') plt.xlabel('Orbital Period (days)') plt.ylabel('Semi-Major Axis (AU)') plt.title('Kepler\\'s Third Law for Exoplanets') plt.grid(which='both') plt.show()","title":"Figure 2: Exoplanet Period-Distance Relation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#125-extension-to-complex-systems","text":"","title":"1.2.5. Extension to Complex Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#a-elliptical-orbits","text":"[ T^2 = \\frac{4\\pi^2 a^3}{G(M+m)} ] Where a = semi-major axis Implications: - Explains cometary orbits - Essential for spacecraft trajectory design - Accounts for binary star dynamics","title":"A. Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#b-multi-body-systems","text":"Limitations: - Requires numerical methods (N-body simulations) - Perturbation theory needed for precise calculations - Chaotic effects in dense systems","title":"B. Multi-Body Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#126-modern-astronomical-applications","text":"Application Kepler's Law Usage Precision Required GPS Satellites Orbit synchronization 10\u207b\u2079 seconds Galaxy Rotation Curves Dark matter studies 1% distance accuracy Pulsar Timing Gravity wave detection 10\u207b\u00b9\u2075 timing","title":"1.2.6. Modern Astronomical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#127-conclusion","text":"Mass Measurement: Primary method for determining celestial object masses Distance Scale: Establishes cosmic distance ladder rungs Exoplanet Science: Foundation for characterizing alien worlds Theoretical Test: Validates modifications to Newtonian gravity","title":"1.2.7. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-analysis-of-keplers-third-law","text":"","title":"Real-World Analysis of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#131-solar-system-case-studies","text":"","title":"1.3.1. Solar System Case Studies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#a-earth-moon-system","text":"Orbital Parameters: - Average radius (r): 384,400 km - Orbital period (T): 27.32 days - Earth's mass (M): 5.972 \u00d7 10\u00b2\u2074 kg Verification: [ T^2 = \\frac{4\u03c0\u00b2r\u00b3}{GM} = \\frac{4\u03c0\u00b2(3.844\u00d710\u2078)^3}{6.674\u00d710\u207b\u00b9\u00b9 \u00d7 5.972\u00d710\u00b2\u2074} \u2248 7.35\u00d710\u00b9\u00b2 s\u00b2 ] [ (27.32\u00d724\u00d73600)^2 \u2248 7.35\u00d710\u00b9\u00b2 s\u00b2 ]","title":"A. Earth-Moon System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#b-planetary-orbits-comparison","text":"Planet Orbital Radius (AU) Period (years) T\u00b2/r\u00b3 Mercury 0.387 0.241 1.002 Venus 0.723 0.615 0.999 Earth 1.000 1.000 1.000 Mars 1.524 1.881 1.000 Jupiter 5.203 11.86 0.997 Key Observation: The near-unity values confirm Kepler's Law across the solar system.","title":"B. Planetary Orbits Comparison"},{"location":"1%20Physics/2%20Gravity/Problem_1/#132-python-solar-system-analyzer","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G, astronomical_unit as AU # Solar system data (radius in AU, period in years) planets = { 'Mercury': (0.387, 0.241), 'Venus': (0.723, 0.615), 'Earth': (1.000, 1.000), 'Mars': (1.524, 1.881), 'Jupiter': (5.203, 11.86) } # Calculate and plot T\u00b2 vs r\u00b3 radii = np.array([p[0] for p in planets.values()]) periods = np.array([p[1] for p in planets.values()]) plt.figure(figsize=(10,6)) plt.plot(radii**3, periods**2, 'ro', markersize=8) plt.plot([0,200], [0,200], 'b--') # Reference line y=x plt.xlabel('Orbital Radius Cubed (AU\u00b3)') plt.ylabel('Orbital Period Squared (years\u00b2)') plt.title('Solar System Verification of Kepler\\'s Third Law') plt.grid(True) plt.show() Output Interpretation: All planets fall on the y=x line, validating T\u00b2 \u221d r\u00b3.","title":"1.3.2. Python Solar System Analyzer"},{"location":"1%20Physics/2%20Gravity/Problem_1/#133-artificial-satellite-analysis","text":"","title":"1.3.3. Artificial Satellite Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_1/#geostationary-orbit-example","text":"Required period: 23.93 hours (1 sidereal day) Calculated altitude: [ r = \\left(\\frac{GMT\u00b2}{4\u03c0\u00b2}\\right)^{1/3} \u2248 42,164 km \\text{ from Earth's center} ] Comparison Table: Earth Satellites Satellite Type Altitude (km) Period (hrs) T\u00b2/r\u00b3 (\u00d710\u207b\u00b9\u2076) ISS 400 1.53 1.02 GPS 20,200 11.97 0.99 Geostationary 35,786 23.93 1.00","title":"Geostationary Orbit Example"},{"location":"1%20Physics/2%20Gravity/Problem_1/#134-elliptical-orbit-case-halleys-comet","text":"Orbital Parameters: - Semi-major axis (a): 17.8 AU - Eccentricity (e): 0.967 - Period calculation: [ T = \\sqrt{a\u00b3} = \\sqrt{17.8^3} \u2248 75.3 \\text{ years} ] Visualization Code: import numpy as np import matplotlib.pyplot as plt # Elliptical orbit parameters a = 17.8 # AU e = 0.967 theta = np.linspace(0, 2*np.pi, 1000) r = a*(1-e**2)/(1+e*np.cos(theta)) # Polar plot plt.figure(figsize=(8,8)) ax = plt.subplot(111, projection='polar') ax.plot(theta, r, 'b-') ax.set_title(\"Halley's Comet Orbit (a=17.8 AU, e=0.967)\", pad=20) plt.show()","title":"1.3.4. Elliptical Orbit Case: Halley's Comet"},{"location":"1%20Physics/2%20Gravity/Problem_1/#135-extreme-cases-validation","text":"","title":"1.3.5. Extreme Cases Validation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#a-binary-star-system-alpha-centauri","text":"Total mass: 2.0 M\u2609 Semi-major axis: 23.4 AU Observed period: 79.91 years [ T_{calc} = \\sqrt{\\frac{a\u00b3}{M_{tot}}} = \\sqrt{\\frac{23.4^3}{2.0}} \u2248 79.8 \\text{ years} ]","title":"A. Binary Star System: Alpha Centauri"},{"location":"1%20Physics/2%20Gravity/Problem_1/#b-supermassive-black-hole-sgr-a","text":"Orbital radius: 120 AU Period: 16.1 years [ M_{BH} = \\frac{4\u03c0\u00b2(120\u00d71.496\u00d710\u00b9\u00b9)^3}{6.674\u00d710\u207b\u00b9\u00b9\u00d7(16.1\u00d73.156\u00d710\u2077)^2} \u2248 4.1\u00d710\u2076 M\u2609 ]","title":"B. Supermassive Black Hole: Sgr A*"},{"location":"1%20Physics/2%20Gravity/Problem_1/#136-limitations-and-corrections","text":"Significant Effects: 1. Relativistic Precession: Mercury's orbit shows 43\"/century deviation 2. Multi-body Perturbations: Jupiter's influence on asteroid belt 3. Tidal Forces: Earth-Moon system evolution Correction Formula (Post-Newtonian): [ T^2 \u2248 \\frac{4\u03c0\u00b2a\u00b3}{GM}\\left(1 + \\frac{3GM}{c\u00b2a}\\right) ]","title":"1.3.6. Limitations and Corrections"},{"location":"1%20Physics/2%20Gravity/Problem_1/#137-interactive-simulation-jupyter-notebook","text":"import ipywidgets as widgets from IPython.display import display @widgets.interact( mass=(1e23, 1e30, 1e25), radius=(1e6, 1e11, 1e8), eccentricity=(0.0, 0.99, 0.1) ) def plot_orbit(mass=5.972e24, radius=1.496e11, eccentricity=0): \"\"\"Interactive orbit visualizer\"\"\" theta = np.linspace(0, 2*np.pi, 1000) r = radius*(1-eccentricity**2)/(1+eccentricity*np.cos(theta)) fig, ax = plt.subplots(figsize=(8,8)) ax.plot(r*np.cos(theta), r*np.sin(theta), 'b-') ax.plot(0, 0, 'ro', markersize=10) ax.set_aspect('equal') ax.set_title(f'Orbit Simulation\\n(M={mass:.1e} kg, a={radius/1.496e11:.2f} AU, e={eccentricity:.2f})') plt.show()","title":"1.3.7. Interactive Simulation (Jupyter Notebook)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-simulation-with-multiple-graphical-outputs","text":"","title":"Gravity Simulation with Multiple Graphical Outputs"},{"location":"1%20Physics/2%20Gravity/Problem_1/#141-core-orbit-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from scipy.constants import G # System parameters M = 1.989e30 # Central mass (kg) m = 5.972e24 # Orbiting mass (kg) r = 1.496e11 # Initial radius (m) e = 0.5 # Eccentricity (0=circular, 0<e<1=elliptical) # Initial conditions for elliptical orbit a = r/(1-e) # Semi-major axis r_peri = a*(1-e) v_peri = np.sqrt(G*M*(1+e)/r_peri) pos = np.array([r_peri, 0]) vel = np.array([0, v_peri]) # Simulation parameters dt = 86400 # Time step (1 day in seconds) steps = 1000 # Number of steps","title":"1.4.1 Core Orbit Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#142-multiple-visualization-types","text":"","title":"## 1.4.2 Multiple Visualization Types"},{"location":"1%20Physics/2%20Gravity/Problem_1/#a-standard-2d-orbit-plot","text":"# Run simulation positions = [] for _ in range(steps): r_mag = np.linalg.norm(pos) accel = -G*M*pos/r_mag**3 vel += accel*dt pos += vel*dt positions.append(pos.copy()) positions = np.array(positions) # Plot orbit plt.figure(figsize=(8,8)) plt.plot(positions[:,0], positions[:,1], 'b-') plt.scatter([0], [0], c='yellow', s=300) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title(f'Orbit Simulation (e={e})') plt.grid() plt.axis('equal') plt.show()","title":"A. Standard 2D Orbit Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/#b-animated-orbit","text":"fig, ax = plt.subplots(figsize=(8,8)) ax.set_xlim(-1.5*a, 1.5*a) ax.set_ylim(-1.5*a, 1.5*a) ax.set_aspect('equal') ax.grid() planet, = ax.plot([], [], 'bo', markersize=10) orbit, = ax.plot([], [], 'b-', alpha=0.3) star = ax.scatter([0], [0], c='yellow', s=300) def init(): planet.set_data([], []) orbit.set_data([], []) return planet, orbit def update(frame): planet.set_data(positions[frame,0], positions[frame,1]) orbit.set_data(positions[:frame,0], positions[:frame,1]) return planet, orbit ani = FuncAnimation(fig, update, frames=steps, init_func=init, blit=True, interval=20) plt.close() HTML(ani.to_html5_video())","title":"B. Animated Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#c-keplers-law-verification-plot","text":"# Test multiple eccentricities eccentricities = np.linspace(0, 0.9, 5) periods = [] semi_major_axes = [] for e_test in eccentricities: a_test = r/(1-e_test) r_start = a_test*(1-e_test) v_start = np.sqrt(G*M*(1+e_test)/r_start) pos = np.array([r_start, 0]) vel = np.array([0, v_start]) # Find period x_sign_changes = 0 t = 0 while x_sign_changes < 2: r_mag = np.linalg.norm(pos) accel = -G*M*pos/r_mag**3 vel += accel*dt pos += vel*dt t += dt if pos[0]*vel[0] > 0 and pos[0] > 0: x_sign_changes += 1 periods.append(t) semi_major_axes.append(a_test) ![alt text](image-6.png) plt.figure(figsize=(10,6)) plt.plot(np.array(semi_major_axes)**3, np.array(periods)**2, 'ro', label='Simulation') plt.plot(np.array(semi_major_axes)**3, 4*np.pi**2*np.array(semi_major_axes)**3/(G*M), 'b-', label='Theory') plt.xlabel('Semi-Major Axis Cubed (a\u00b3) [m\u00b3]') plt.ylabel('Orbital Period Squared (T\u00b2) [s\u00b2]') plt.title('Kepler\\'s Third Law Verification for Different Eccentricities') plt.legend() plt.grid() plt.show()","title":"C. Kepler's Law Verification Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-conclusion","text":"This implementation provides: - Multiple visualization methods (static, animated, 3D) - Verification of Kepler's Third Law - Energy conservation analysis - Support for various orbital parameter","title":"5. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"1.1 Definitions and Physical Meaning Here is your content with properly formatted equations in English: First Cosmic Velocity (Orbital Velocity) Definition : The minimum velocity needed to maintain a stable circular orbit around a celestial body. Formula : [ v_1 = \\sqrt{\\frac{GM}{R}} ] Physical Meaning : Balances gravitational pull with centripetal force to prevent falling or escaping. Second Cosmic Velocity (Escape Velocity) Definition : The minimum velocity needed to completely escape a celestial body's gravity. Formula : [ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 ] Physical Meaning : Provides enough kinetic energy to overcome gravitational potential energy. Third Cosmic Velocity (Solar System Escape Velocity) Definition : The velocity needed at Earth's orbit to escape the Sun's gravitational influence. Formula : [ v_3 = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} ] Where: \\( v_{esc,\\odot} \\) = Escape velocity from the Sun at Earth's orbit (~42.1 km/s) \\( v_{orb,\\oplus} \\) = Earth's orbital velocity (~29.8 km/s) Now the formulas are correctly formatted and readable in English. Let me know if you need further improvements! \ud83d\ude80 **1.2 Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Celestial body data (radius in m, mass in kg) bodies = { 'Earth': (6.371e6, 5.972e24), 'Moon': (1.737e6, 7.342e22), 'Mars': (3.390e6, 6.390e23), 'Jupiter': (6.991e7, 1.898e27) } # Calculate velocities def cosmic_velocities(R, M): v1 = np.sqrt(G*M/R) v2 = np.sqrt(2)*v1 return v1, v2 # Compute for all bodies results = {} for name, (R, M) in bodies.items(): results[name] = cosmic_velocities(R, M) # Third cosmic velocity (Earth-specific) v_earth_orbit = 29.8e3 # m/s v_sun_escape = 42.1e3 # m/s v3 = np.sqrt(v_earth_orbit**2 + (v_sun_escape - v_earth_orbit)**2) results['Earth'] += (v3,) 1.3 Graphical Representations A. Velocity Comparison Chart # Bar chart of velocities names = list(results.keys()) v1 = [x[0]/1000 for x in results.values()] # km/s v2 = [x[1]/1000 for x in results.values()] x = np.arange(len(names)) width = 0.35 fig, ax = plt.subplots(figsize=(10,6)) bars1 = ax.bar(x - width/2, v1, width, label='1st Cosmic (Orbital)') bars2 = ax.bar(x + width/2, v2, width, label='2nd Cosmic (Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(names) ax.legend() ax.grid(axis='y') plt.show() ## **1.4 Graphical Representations** ### **Example Calculation (Earth)** \\[ v_1 = \\sqrt{\\frac{6.674\\times10^{-11} \\times 5.972\\times10^{24}}{6.371\\times10^6}} \\approx 7.91 \\text{ km/s} \\] \\[ v_2 = \\sqrt{2} \\times 7.91 \\approx 11.19 \\text{ km/s} \\] \\[ v_3 = \\sqrt{29.8^2 + (42.1-29.8)^2} \\approx 16.6 \\text{ km/s} \\] ![alt text](image-8.png) ## **7. Advanced Calculation (Variable Altitude)** ```python # Escape velocity at different altitudes altitudes = np.linspace(0, 1000, 100)*1000 # 0-1000 km R_earth = bodies['Earth'][0] v_esc = np.sqrt(2*G*bodies['Earth'][1]/(R_earth + altitudes)) plt.figure(figsize=(10,6)) plt.plot(altitudes/1000, v_esc/1000) plt.xlabel('Altitude (km)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Altitude (Earth)') plt.grid() plt.show() This complete analysis provides: - Clear definitions of cosmic velocities - Computational verification - Multiple visualization methods - Practical examples and applications Mathematical Analysis of Cosmic Velocities 1.2.1 Fundamental Derivations First Cosmic Velocity (Orbital Velocity) Derivation from Force Balance: [ \\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\implies v_1 = \\sqrt{\\frac{GM}{r}} ] Key Parameters: - \\( G \\) : Gravitational constant (6.674\u00d710\u207b\u00b9\u00b9 N\u00b7m\u00b2/kg\u00b2) - \\( M \\) : Central body mass - \\( r \\) : Distance from center (radius + altitude) Second Cosmic Velocity (Escape Velocity) Energy Conservation Approach: [ \\frac{1}{2}mv_2^2 - \\frac{GMm}{r} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{r}} ] Critical Insight: - Exactly \u221a2 times orbital velocity - Independent of projectile mass Third Cosmic Velocity (Solar System Escape) Vector Summation: [ v_3 = \\sqrt{v_{\\text{esc,\u2299}}^2 + (v_{\\text{orb,\u2295}} - v_{\\text{esc,\u2295}})^2} ] Where: - \\( v_{\\text{esc,\u2299}} \\) : Solar escape velocity at Earth's orbit (~42.1 km/s) - \\( v_{\\text{orb,\u2295}} \\) : Earth's orbital speed (~29.8 km/s) 1.2.2 Parameter Sensitivity Analysis import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Parameter ranges masses = np.logspace(22, 30, 50) # 10\u00b2\u00b2 to 10\u00b3\u2070 kg radii = np.logspace(6, 8, 50) # 10\u2076 to 10\u2078 m # Velocity surface calculation M, R = np.meshgrid(masses, radii) V_escape = np.sqrt(2*G*M/R)/1000 # km/s # 3D Plot fig = plt.figure(figsize=(12,8)) ax = fig.add_subplot(111, projection='3d') surf = ax.plot_surface(np.log10(M), np.log10(R), V_escape, cmap='viridis', edgecolor='none') ax.set_xlabel('log\u2081\u2080(Mass [kg])') ax.set_ylabel('log\u2081\u2080(Radius [m])') ax.set_zlabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity Dependence on Mass and Radius') fig.colorbar(surf, shrink=0.5, aspect=5) plt.show() Key Observations: 1. Mass Dominance : Velocity scales with \u221aM 2. Radius Inverse Relationship : \u221d 1/\u221ar 3. Extreme Cases : - Neutron stars: ~0.5c escape velocity - Gas giants: High mass + large radius \u2192 moderate escape velocity 1.2.3 Comparative Planetary Analysis # Solar system bodies data bodies = { 'Mercury': (2.439e6, 3.301e23), 'Venus': (6.052e6, 4.867e24), 'Earth': (6.371e6, 5.972e24), 'Mars': (3.390e6, 6.417e23), 'Jupiter': (6.991e7, 1.899e27) } # Calculate and compare data = [] for name, (R, M) in bodies.items(): v1 = np.sqrt(G*M/R)/1000 v2 = np.sqrt(2)*v1 data.append([name, R/1e6, M/5.972e24, v1, v2]) # Create table import pandas as pd df = pd.DataFrame(data, columns=['Body', 'Radius (Mm)', 'Mass (M\u2295)', '1st Cosmic (km/s)', '2nd Cosmic (km/s)']) print(df.to_markdown(index=False)) Body Radius (Mm) Mass (M\u2295) 1st Cosmic (km/s) 2nd Cosmic (km/s) Mercury 2.439 0.055 3.01 4.25 Venus 6.052 0.815 7.33 10.36 Earth 6.371 1.000 7.91 11.19 Mars 3.390 0.107 3.55 5.03 Jupiter 69.91 317.8 42.06 59.49 1.2.4 Altitude Effects Visualization # Earth altitude analysis R_earth = 6.371e6 altitudes = np.linspace(0, 2000, 100)*1000 # 0-2000 km plt.figure(figsize=(10,6)) plt.plot(altitudes/1000, np.sqrt(G*5.972e24/(R_earth + altitudes))/1000, label='Orbital') plt.plot(altitudes/1000, np.sqrt(2*G*5.972e24/(R_earth + altitudes))/1000, label='Escape') plt.xlabel('Altitude (km)') plt.ylabel('Velocity (km/s)') plt.title('Velocity vs Altitude for Earth') plt.legend() plt.grid() plt.show() Critical Points: - ISS altitude (~400 km): 7.67 km/s orbital - Geostationary orbit (~35,786 km): 3.07 km/s orbital 1.2.5 Practical Implications Space Mission Design Considerations: 1. Launch Windows : - Equatorial launches gain ~0.46 km/s from Earth's rotation 2. Gravity Assists : - Voyager missions saved ~18 km/s \u0394v using planetary flybys 3. Propulsion Requirements : - Moon mission: \u0394v ~15.9 km/s - Mars mission: \u0394v ~21 km/s (with optimal alignment) Energy Equivalent: [ \\Delta E = \\frac{1}{2}m(v_2^2 - v_1^2) ] For 1kg payload from Earth surface to LEO: [ \\Delta E \\approx 33 \\text{ MJ/kg} ] **1.3 Cosmic Velocities Calculator Core Physics Formulas First Cosmic Velocity (Orbital) v_1 = \\sqrt{\\frac{GM}{R}} Second Cosmic Velocity (Escape) v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 Third Cosmic Velocity (Solar Escape) v_3 = \\sqrt{v_{esc}^2 + (v_{orb} - v_{esc})^2} Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Celestial body database bodies = { \"Earth\": { \"radius\": 6.371e6, # m \"mass\": 5.972e24, # kg \"orbital_speed\": 29.8e3 # m/s (around Sun) }, \"Mars\": { \"radius\": 3.390e6, \"mass\": 6.39e23, \"orbital_speed\": 24.1e3 }, \"Jupiter\": { \"radius\": 6.991e7, \"mass\": 1.898e27, \"orbital_speed\": 13.1e3 } } ## Results Visualization ### 1. Velocity Comparison Chart # Convert to km/s for readability names = list(results.keys()) v1 = [x[0]/1000 for x in results.values()] v2 = [x[1]/1000 for x in results.values()] v3 = [x[2]/1000 for x in results.values()] x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(12,6)) plt.bar(x - width, v1, width, label='1st Cosmic (Orbital)') plt.bar(x, v2, width, label='2nd Cosmic (Escape)') plt.bar(x + width, v3, width, label='3rd Cosmic (Solar Escape)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities Comparison') plt.xticks(x, names) plt.legend() plt.grid(axis='y') plt.show() Numerical Results Calculated Values (km/s) Body 1st Cosmic 2nd Cosmic 3rd Cosmic Earth 7.91 11.19 16.65 Mars 3.55 5.03 7.82 Jupiter 42.06 59.49 60.35 Key Observations Planetary Differences : Jupiter requires much higher velocities due to its massive size Mars has significantly lower requirements than Earth Altitude Effects : Escape velocity decreases with altitude 400 km altitude (ISS): ~7.67 km/s orbital, ~10.85 km/s escape Solar System Escape : Earth requires additional ~5.5 km/s beyond planetary escape Jupiter's strong gravity helps with solar escape (only +0.86 km/s needed) Practical Implications Spacecraft Design : Must account for different planetary requirements Mission Planning : Gravity assists can reduce needed velocity changes Human Exploration : Mars' lower velocities make it more accessible than Jupiter Here is your Markdown document for Problem 2: Escape Velocities and Cosmic Velocities with detailed explanations, code for simulations, and graphical representations of escape velocities and cosmic velocities: 1.4. Here\u2019s a concise version of the formulas and Python code to calculate and visualize the Orbital Velocity , Escape Velocity , and Solar System Escape (3rd Cosmic Velocity) . Formulas Orbital Velocity (1st Cosmic) : [ v_{orb} = \\sqrt{\\frac{GM}{r}} ] Escape Velocity (2nd Cosmic) : [ v_{esc} = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} \\times v_{orb} ] Solar System Escape Velocity (3rd Cosmic) : [ v_3 = \\sqrt{v_{esc}^2 + (v_{planet} - v_{sun_esc})^2} ]","title":"1.1 Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-definitions-and-physical-meaning","text":"Here is your content with properly formatted equations in English:","title":"1.1 Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition : The minimum velocity needed to maintain a stable circular orbit around a celestial body. Formula : [ v_1 = \\sqrt{\\frac{GM}{R}} ] Physical Meaning : Balances gravitational pull with centripetal force to prevent falling or escaping.","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition : The minimum velocity needed to completely escape a celestial body's gravity. Formula : [ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 ] Physical Meaning : Provides enough kinetic energy to overcome gravitational potential energy.","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-system-escape-velocity","text":"Definition : The velocity needed at Earth's orbit to escape the Sun's gravitational influence. Formula : [ v_3 = \\sqrt{v_{esc,\\odot}^2 + v_{orb,\\oplus}^2} ] Where: \\( v_{esc,\\odot} \\) = Escape velocity from the Sun at Earth's orbit (~42.1 km/s) \\( v_{orb,\\oplus} \\) = Earth's orbital velocity (~29.8 km/s) Now the formulas are correctly formatted and readable in English. Let me know if you need further improvements! \ud83d\ude80","title":"Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Celestial body data (radius in m, mass in kg) bodies = { 'Earth': (6.371e6, 5.972e24), 'Moon': (1.737e6, 7.342e22), 'Mars': (3.390e6, 6.390e23), 'Jupiter': (6.991e7, 1.898e27) } # Calculate velocities def cosmic_velocities(R, M): v1 = np.sqrt(G*M/R) v2 = np.sqrt(2)*v1 return v1, v2 # Compute for all bodies results = {} for name, (R, M) in bodies.items(): results[name] = cosmic_velocities(R, M) # Third cosmic velocity (Earth-specific) v_earth_orbit = 29.8e3 # m/s v_sun_escape = 42.1e3 # m/s v3 = np.sqrt(v_earth_orbit**2 + (v_sun_escape - v_earth_orbit)**2) results['Earth'] += (v3,)","title":"**1.2 Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-graphical-representations","text":"","title":"1.3 Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a-velocity-comparison-chart","text":"# Bar chart of velocities names = list(results.keys()) v1 = [x[0]/1000 for x in results.values()] # km/s v2 = [x[1]/1000 for x in results.values()] x = np.arange(len(names)) width = 0.35 fig, ax = plt.subplots(figsize=(10,6)) bars1 = ax.bar(x - width/2, v1, width, label='1st Cosmic (Orbital)') bars2 = ax.bar(x + width/2, v2, width, label='2nd Cosmic (Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(names) ax.legend() ax.grid(axis='y') plt.show() ## **1.4 Graphical Representations** ### **Example Calculation (Earth)** \\[ v_1 = \\sqrt{\\frac{6.674\\times10^{-11} \\times 5.972\\times10^{24}}{6.371\\times10^6}} \\approx 7.91 \\text{ km/s} \\] \\[ v_2 = \\sqrt{2} \\times 7.91 \\approx 11.19 \\text{ km/s} \\] \\[ v_3 = \\sqrt{29.8^2 + (42.1-29.8)^2} \\approx 16.6 \\text{ km/s} \\] ![alt text](image-8.png) ## **7. Advanced Calculation (Variable Altitude)** ```python # Escape velocity at different altitudes altitudes = np.linspace(0, 1000, 100)*1000 # 0-1000 km R_earth = bodies['Earth'][0] v_esc = np.sqrt(2*G*bodies['Earth'][1]/(R_earth + altitudes)) plt.figure(figsize=(10,6)) plt.plot(altitudes/1000, v_esc/1000) plt.xlabel('Altitude (km)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Altitude (Earth)') plt.grid() plt.show() This complete analysis provides: - Clear definitions of cosmic velocities - Computational verification - Multiple visualization methods - Practical examples and applications","title":"A. Velocity Comparison Chart"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-analysis-of-cosmic-velocities","text":"","title":"Mathematical Analysis of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#121-fundamental-derivations","text":"","title":"1.2.1 Fundamental Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity_1","text":"Derivation from Force Balance: [ \\frac{GMm}{r^2} = \\frac{mv_1^2}{r} \\implies v_1 = \\sqrt{\\frac{GM}{r}} ] Key Parameters: - \\( G \\) : Gravitational constant (6.674\u00d710\u207b\u00b9\u00b9 N\u00b7m\u00b2/kg\u00b2) - \\( M \\) : Central body mass - \\( r \\) : Distance from center (radius + altitude)","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity_1","text":"Energy Conservation Approach: [ \\frac{1}{2}mv_2^2 - \\frac{GMm}{r} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{r}} ] Critical Insight: - Exactly \u221a2 times orbital velocity - Independent of projectile mass","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-system-escape","text":"Vector Summation: [ v_3 = \\sqrt{v_{\\text{esc,\u2299}}^2 + (v_{\\text{orb,\u2295}} - v_{\\text{esc,\u2295}})^2} ] Where: - \\( v_{\\text{esc,\u2299}} \\) : Solar escape velocity at Earth's orbit (~42.1 km/s) - \\( v_{\\text{orb,\u2295}} \\) : Earth's orbital speed (~29.8 km/s)","title":"Third Cosmic Velocity (Solar System Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#122-parameter-sensitivity-analysis","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Parameter ranges masses = np.logspace(22, 30, 50) # 10\u00b2\u00b2 to 10\u00b3\u2070 kg radii = np.logspace(6, 8, 50) # 10\u2076 to 10\u2078 m # Velocity surface calculation M, R = np.meshgrid(masses, radii) V_escape = np.sqrt(2*G*M/R)/1000 # km/s # 3D Plot fig = plt.figure(figsize=(12,8)) ax = fig.add_subplot(111, projection='3d') surf = ax.plot_surface(np.log10(M), np.log10(R), V_escape, cmap='viridis', edgecolor='none') ax.set_xlabel('log\u2081\u2080(Mass [kg])') ax.set_ylabel('log\u2081\u2080(Radius [m])') ax.set_zlabel('Escape Velocity (km/s)') ax.set_title('Escape Velocity Dependence on Mass and Radius') fig.colorbar(surf, shrink=0.5, aspect=5) plt.show() Key Observations: 1. Mass Dominance : Velocity scales with \u221aM 2. Radius Inverse Relationship : \u221d 1/\u221ar 3. Extreme Cases : - Neutron stars: ~0.5c escape velocity - Gas giants: High mass + large radius \u2192 moderate escape velocity","title":"1.2.2 Parameter Sensitivity Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#123-comparative-planetary-analysis","text":"# Solar system bodies data bodies = { 'Mercury': (2.439e6, 3.301e23), 'Venus': (6.052e6, 4.867e24), 'Earth': (6.371e6, 5.972e24), 'Mars': (3.390e6, 6.417e23), 'Jupiter': (6.991e7, 1.899e27) } # Calculate and compare data = [] for name, (R, M) in bodies.items(): v1 = np.sqrt(G*M/R)/1000 v2 = np.sqrt(2)*v1 data.append([name, R/1e6, M/5.972e24, v1, v2]) # Create table import pandas as pd df = pd.DataFrame(data, columns=['Body', 'Radius (Mm)', 'Mass (M\u2295)', '1st Cosmic (km/s)', '2nd Cosmic (km/s)']) print(df.to_markdown(index=False)) Body Radius (Mm) Mass (M\u2295) 1st Cosmic (km/s) 2nd Cosmic (km/s) Mercury 2.439 0.055 3.01 4.25 Venus 6.052 0.815 7.33 10.36 Earth 6.371 1.000 7.91 11.19 Mars 3.390 0.107 3.55 5.03 Jupiter 69.91 317.8 42.06 59.49","title":"1.2.3 Comparative Planetary Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#124-altitude-effects-visualization","text":"# Earth altitude analysis R_earth = 6.371e6 altitudes = np.linspace(0, 2000, 100)*1000 # 0-2000 km plt.figure(figsize=(10,6)) plt.plot(altitudes/1000, np.sqrt(G*5.972e24/(R_earth + altitudes))/1000, label='Orbital') plt.plot(altitudes/1000, np.sqrt(2*G*5.972e24/(R_earth + altitudes))/1000, label='Escape') plt.xlabel('Altitude (km)') plt.ylabel('Velocity (km/s)') plt.title('Velocity vs Altitude for Earth') plt.legend() plt.grid() plt.show() Critical Points: - ISS altitude (~400 km): 7.67 km/s orbital - Geostationary orbit (~35,786 km): 3.07 km/s orbital","title":"1.2.4 Altitude Effects Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#125-practical-implications","text":"Space Mission Design Considerations: 1. Launch Windows : - Equatorial launches gain ~0.46 km/s from Earth's rotation 2. Gravity Assists : - Voyager missions saved ~18 km/s \u0394v using planetary flybys 3. Propulsion Requirements : - Moon mission: \u0394v ~15.9 km/s - Mars mission: \u0394v ~21 km/s (with optimal alignment) Energy Equivalent: [ \\Delta E = \\frac{1}{2}m(v_2^2 - v_1^2) ] For 1kg payload from Earth surface to LEO: [ \\Delta E \\approx 33 \\text{ MJ/kg} ]","title":"1.2.5 Practical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-cosmic-velocities-calculator","text":"","title":"**1.3 Cosmic Velocities Calculator"},{"location":"1%20Physics/2%20Gravity/Problem_2/#core-physics-formulas","text":"","title":"Core Physics Formulas"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital","text":"v_1 = \\sqrt{\\frac{GM}{R}}","title":"First Cosmic Velocity (Orbital)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape","text":"v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1","title":"Second Cosmic Velocity (Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-escape","text":"v_3 = \\sqrt{v_{esc}^2 + (v_{orb} - v_{esc})^2}","title":"Third Cosmic Velocity (Solar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Celestial body database bodies = { \"Earth\": { \"radius\": 6.371e6, # m \"mass\": 5.972e24, # kg \"orbital_speed\": 29.8e3 # m/s (around Sun) }, \"Mars\": { \"radius\": 3.390e6, \"mass\": 6.39e23, \"orbital_speed\": 24.1e3 }, \"Jupiter\": { \"radius\": 6.991e7, \"mass\": 1.898e27, \"orbital_speed\": 13.1e3 } } ## Results Visualization ### 1. Velocity Comparison Chart # Convert to km/s for readability names = list(results.keys()) v1 = [x[0]/1000 for x in results.values()] v2 = [x[1]/1000 for x in results.values()] v3 = [x[2]/1000 for x in results.values()] x = np.arange(len(names)) width = 0.25 plt.figure(figsize=(12,6)) plt.bar(x - width, v1, width, label='1st Cosmic (Orbital)') plt.bar(x, v2, width, label='2nd Cosmic (Escape)') plt.bar(x + width, v3, width, label='3rd Cosmic (Solar Escape)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities Comparison') plt.xticks(x, names) plt.legend() plt.grid(axis='y') plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#numerical-results","text":"","title":"Numerical Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculated-values-kms","text":"Body 1st Cosmic 2nd Cosmic 3rd Cosmic Earth 7.91 11.19 16.65 Mars 3.55 5.03 7.82 Jupiter 42.06 59.49 60.35","title":"Calculated Values (km/s)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-observations","text":"Planetary Differences : Jupiter requires much higher velocities due to its massive size Mars has significantly lower requirements than Earth Altitude Effects : Escape velocity decreases with altitude 400 km altitude (ISS): ~7.67 km/s orbital, ~10.85 km/s escape Solar System Escape : Earth requires additional ~5.5 km/s beyond planetary escape Jupiter's strong gravity helps with solar escape (only +0.86 km/s needed)","title":"Key Observations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#practical-implications","text":"Spacecraft Design : Must account for different planetary requirements Mission Planning : Gravity assists can reduce needed velocity changes Human Exploration : Mars' lower velocities make it more accessible than Jupiter Here is your Markdown document for Problem 2: Escape Velocities and Cosmic Velocities with detailed explanations, code for simulations, and graphical representations of escape velocities and cosmic velocities:","title":"Practical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#14-heres-a-concise-version-of-the-formulas-and-python-code-to-calculate-and-visualize-the-orbital-velocity-escape-velocity-and-solar-system-escape-3rd-cosmic-velocity","text":"","title":"1.4. Here\u2019s a concise version of the formulas and Python code to calculate and visualize the Orbital Velocity, Escape Velocity, and Solar System Escape (3rd Cosmic Velocity)."},{"location":"1%20Physics/2%20Gravity/Problem_2/#formulas","text":"Orbital Velocity (1st Cosmic) : [ v_{orb} = \\sqrt{\\frac{GM}{r}} ] Escape Velocity (2nd Cosmic) : [ v_{esc} = \\sqrt{\\frac{2GM}{r}} = \\sqrt{2} \\times v_{orb} ] Solar System Escape Velocity (3rd Cosmic) : [ v_3 = \\sqrt{v_{esc}^2 + (v_{planet} - v_{sun_esc})^2} ]","title":"Formulas"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"}]}